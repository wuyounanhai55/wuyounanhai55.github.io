<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[brower]]></title>
    <url>%2F2019%2F09%2F11%2Fbrower%2F</url>
    <content type="text"><![CDATA[浏览器的基本工作原理 浏览器多进程架构 Chrome 由多进程(process)组成，每个进程都有自己核心职责，每个进程包含多个线程(thread)，一个进程内的多个线程之间也会协同工作，配合完成所在进程职责。 进程(process)和线程(thread) 进程就像有边界的生产车间，线程就像车间内的一个个员工，可以自己做自己的事情，也可以相互配合做同一件事情。当启动一个应用时，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据，应用关闭，进程终结，操作系统释放内存。一个进程还可以要求操作系统生成另一个进程来执行不同任务，系统为新的进程分配独立内存，两个进程之间可以使用IPC(Inter Process Communication)进行通信。如果一个进程反应迟钝，重启这个进程不会影响其他进程工作。点击查看更多关于进程和线程 浏览器的架构它可以是单进程多线程的应用，也可以使用IPC通信的多进程应用，不同浏览器采用不同架构，并不存在标准模式，以Chrome为例：Chorme采用多进程架构，顶层存在一个Browser process用以协调浏览器其他进程具体Chrome的主要进程和职责如下： Browser Process1 负责包括地址栏、书签栏，前进后退按钮等部分的工作2 负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问 Renderer Process1 负责一个tab内关于网页呈现的所有事情 Plugin Process1 负责控制一个网页用到的所有插件，如flash GPU Process1 负责GPU相关的任务 Chrome 多进程架构的优缺点 优点 1 某一渲染进程出问题不会影响其他进程 2 更为安全，在系统层面上限定了不同进程的权限 缺点 由于不同进程之间的内存不共享，不同进程的内存常常需要包含相同的内容 为了节省内存，Chrome限制了最多进程数，最大进程数量由设备的内存和CPU能力决定，当达到这一限制时，新打开的Tab会共用之前同一站点的渲染进程 Chrome把浏览器不同程序的功能，这些服务可以方便的分割为不同的进程或者合并为一个进程。以Browser Process为例，如果Chrome运行在强大的硬件上，它会分割不同的服务到不同的进程，这样Chrome整体运行更加稳定，如果Chrome运行在 资源贫薄的设备上，这些服务又会合并到同一进程中运行，可以节省内存 iframe的渲染 – Site Isolation Site Isolation机制从Chrome67开始默认启用，这种机制允许在同一个Tab下的跨站iframe使用单独进程来渲染，这样会更安全 导航过程发生了什么 浏览器Tab外的工作主要由Browser Process掌控，Browser Process又对这些工作进一步划分，使用不同线程进行处理： UI thread: 控制浏览器的按钮及输入框； network thread: 处理网络请求，从网上获取数据； storage thread: 控制文件等的访问 当我们在浏览器地址栏中输入文字，并点击回车获得页面内容的过程在浏览器看来可以分以下几步： 1 处理输入 UI thread 需要判断用户输入的是URL 还是 query; 2 开始导航 当用户点击回车键，UI thread 通知 netWork thread 获取网页内容，并控制tab上spinner展现，表示正在加载中network thread 会执行DNS查询，随后为请求建立TLS连接如果network thread接收到了重定向请求头如301，network thread会通知UI thread服务器要求重定向，之后另一个URL请求被触发。 3 读取响应 当请求响应返回的时候，network thread会依据Content-Type及MIME Type sniffing判断响应内容的格式，如果响应格式是HTML，下一步将会把这些数据传递给renderer process，如果是zip文件或者是其他文件，会把相关数据传输给下载管理器。Safe Browsing检查也会在此时触发，如果域名或者请求内容匹配到已知恶意站点，network thread会展示一个警告页。此外CORB检测也会触发确保敏感数据不会被传递渲染进程。 4 查找渲染进程 当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread会通知UI thread数据已经准备好，UI thread会查找下一个renderer process进行网页的渲染。 由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当UI thread发生URL请求给network thread时，浏览器其实已经知道了将要导航到那个站点。UI thread会并行的预先查找和启动一个渲染进程，如果一切正常，当network thread接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候需要重启一个新的渲染进程。 5 确认导航 上述过程，数据和渲染进程都可用了，Browser Process会给renderer process发生IPC消息来确认导航，一旦Browser Process收到renderer process的渲染确认消息，导航过程结束，页面加载过程开始，此时，地址栏更新，展示新的页面信息。history tab更新，可通过返回导航键来导航页面，为了关闭tab或者窗口后便于恢复，这些信息存放在硬盘中。 6 额外的步骤 导航被确认，render process会使用相关的资源渲染页面，当render process渲染结束(渲染结束意味着该页面内所有页面，包括iframe都出发onload时),会发送IPC信号到Browser Process, UI thread会停止展示tab里的spinner,上面流程只是网页首帧渲染完成，客户端依旧可以下载额外资源渲染出新视图。所有js代码其实都由render Process控制，所以当浏览网页内容的过程大部分时候不会涉及到其它进程。不过也许你曾经监听过beforeunload事件，这个事件再次涉及到Browser Process和renderer Process的交互，当当前页面关闭时(关闭Tab或者刷新等),Browser Process需要通知render process进行相关检查，对相关事件进行处理。如果导航由 renderer process 触发（比如在用户点击某链接，或者JS执行 window.location = &quot;http://newsite.com&quot; ） renderer process 会首先检查是否有 beforeunload 事件处理器，导航请求由 renderer process 传递给 Browser process如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 unload 等事件除上述流程，有些页面还拥有Service Worker,Service Worker对本地缓存及判断何时从网络上获取信息有了更多控制权，如果service worker被设置为从本地cache中加载数据，那么就没有必要从网上获取更多数据了。值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。如果service worker 最终决定通过网上获取数据，Browser进程和render进程的交互其实会延后数据的请求时间。Navigation Preload是一种与Service Worker并行的加速加载资源机制，服务端通过请求头可以识别这类请求，做出响应的处理 渲染进程是如何工作的渲染进程几乎负责Tab内的所有事情，渲染进程的核心目的在于转换HTML CSS JS为用户可交互的web页面。渲染进程包含以下线程:1、主线程 Main thread2、工作线程 Worker thread3、排版线程 Compositor thread4、光栅线程 Raster thread 渲染流程 1、构建DOM当渲染进程接收到导航的确认信息，开始接受HTML数据时，主线程会解析文本字符串为DOM。2、加载次级资源网页中常常包含诸如图片、CSS、JS等额外的资源，这些资源需要从网络上或者cache中获取。主进程可以在构建DOM过程中会逐一请求它们，为了加速preload scanner 会同时运行，如果在html中存在&lt;img&gt;、&lt;link&gt;等标签,preload scanner会把这些请求传递给Browser Process中的network thread进行相关资源下载。3、JS的下载与执行当遇到&lt;script&gt;标签时，渲染进程会停止解析HTML,而去加载，解析和执行JS代码，停止解析HTML的原因在于JS可能改变DOM结构（使用诸如document.write()等API）。不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在&lt;script&gt; 标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。4、样式计算仅仅渲染DOM还不足以获知页面的具体样式，主进程还会基于CSS选择器解析CSS获取每一个节点的最终的计算样式值。即使不提供任何CSS,浏览器对每个元素也有一个默认的样式5、获取布局想渲染完整页面，除了获取每个节点样式，还需要获知每个节点在页面上的位置，布局就是找所有元素几何关系的过程。通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 display:none ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。6、绘制各元素知道了不同元素的位置和样式信息，还需要知道不同元素绘制先后顺序。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看作是记录各个元素绘制先后顺序的笔记。7、合成帧复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同的层的组合由compositor线程（合成器线程）完成。主线程会遍历布局树来创建层树（layer tree），添加了 will-change CSS 属性的元素，会被看做单独的一层，一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。 浏览器对事件的处理浏览器对不同事件处理来满足各种交互需求。当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。 我们提到过合成器可以独立于主线程之外通过合成栅格化层平滑的处理滚动。如果页面中没有绑定相关事件，组合器线程可以独立于主线程创建组合帧。如果页面绑定了相关事件处理器，主线程就不得不出来工作了。这时候合成器线程会怎么处理呢？这里涉及到一个专业名词「理解非快速滚动区域（non-fast scrollable region）」由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 non-fast scrollable region ，如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。web 开发中常用的事件处理模式是事件委托，基于事件冒泡，我们常常在最顶层绑定事件：12345document.body.addEventListener('touchstart', event =&gt; &#123; if (event.target === area) &#123; event.preventDefault() &#125;&#125;) 上述做法很常见，但是如果从浏览器的角度看，整个页面都成了 non-fast scrollable region 了。这意味着即使操作的是页面无绑定事件处理器的区域，每次输入时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。为防止这种情况，可以为事件处理器传递passive:true，做为参数，这样就能让浏览器即监听相关事件，又让组合器线程在等待主线程响应前构建新的组合帧。12345document.body.addEventListener('touchstart', event =&gt; &#123; if (event.target === area) &#123; event.preventDefault() &#125; &#125;, &#123;passive: true&#125;); 上述写法可能又会带来另外一个问题，假设某个区域你只想要水平滚动，使用 passive: true 可以实现平滑滚动，但是垂直方向的滚动可能会先于event.preventDefault()发生，此时可以通过 event.cancelable 来防止这种情况.12345678document.body.addEventListener('pointermove', event =&gt; &#123; if (event.cancelable) &#123; event.preventDefault(); // block the native scroll /* * do what you want the application to do here */ &#125; &#125;, &#123;passive: true&#125;); 可以使用css属性 touch-action 来完全消除事件处理器的影响，如：123#area &#123; touch-action: pan-x;&#125;]]></content>
      <categories>
        <category>-brower</category>
      </categories>
      <tags>
        <tag>-brower</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise-interview]]></title>
    <url>%2F2019%2F09%2F09%2FPromise-interview%2F</url>
    <content type="text"><![CDATA[Promise总结 Promise的三种状态 1 Pending2 Fulfilled3 Rejected一旦Promise被resolve 或 reject,则状态就不会再更改 基本过程 1 初始化Promise状态（Pending）2 执行then(..)注册回调处理数组(then方法可被同一个Promise调用多次)3 立即执行Promise中传入的fn函数，将Promise内部resolve、reject函数作为参数传递给fn函数，按事件机制时机处理4 Promise里的关键是要保证，then方法传入的参数onFulfilled 和 onRejected,必须在then方法被调用的那一轮事件循环之后的新执行栈中执行** 真正的链式Promise是指在当前promise到达fulfilled状态后，即开始进行下一个promise 链式调用12345678910111213new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;test: 1&#125;) resolve(&#123;test: 2&#125;) reject(&#123;test: 2&#125;) &#125;, 1000)&#125;).then((data) =&gt; &#123; console.log('result1', data)&#125;, (err) =&gt; &#123; console.log('result2', err)&#125;).then((data3) =&gt; &#123; console.log('result3', data3)&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-summarize3]]></title>
    <url>%2F2019%2F06%2F24%2Fjs-summarize3%2F</url>
    <content type="text"><![CDATA[夯实基础，从敲代码开始。 第13章 事件 13.1 事件流 13.1.1 事件冒泡 IE的事件流叫事件冒泡(event bubbling),即事件最开始是由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐渐向上传播到较为不具体的节点。 13.1.2 事件捕获 Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获是不太具体的节点先接收事件，具体的节点最后获取事件，事件捕获用意在于事件到达预定目标之前捕获它。建议使用事件冒泡，有特殊情况使用事件捕获。 13.1.3 DOM事件流 “DOM2级事件”规定事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。即使“DOM2级事件”规范明确要求捕 获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox和 Opera 9.5及更高版本都会在捕获阶段触 发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 13.2 事件处理程序 13.2.1 HTML事件处理程序 1&lt;input type="button" value="Click Me" onclick="showMessage()"&gt; 13.2.2 DOM0级事件处理程序 将一个函数赋值给一个事件处理程序属性。例：12var btn = document.getElementById("myBtn");btn.onclick = function () &#123;alert('click')&#125; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这个时候事件处理程序是在元素的作用域运行的；换句话说，程序中的this引用当前元素。例：1234var btn = document.getElementById("myBtn");btn.onclick = function () &#123; alert(this.id); // myBtn&#125; 以这种方法添加的事件处理程序会在事件流的冒泡阶段被处理。 也可以删除通过 DOM0 级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设 置为 null 即可：1btn.onclick = null; //删除事件处理程序 13.2.3 DOM2级事件处理程序 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener()。所有DOM节点都包含这两个方法。并且都接受三个参数：要处理的事件名、做为事件处理程序的函数、和一个布尔值(true表示在捕获阶段调用程序，false表示在冒泡阶段调用程序)。例：12var btn = document.getElementById("myBtn");btn.addEventListener('click', function () &#123;alert(this.id)&#125;, false) 使用DOM2级方法添加事件处理程序的主要好处是可以添加多种事件处理程序。例：123var btn = document.getElementById("myBtn");btn.addEventListener('click', function () &#123;alert(this.id)&#125;, false)btn.addEventListener('click', function () &#123;alert('hello, world')&#125;, false) 这两个事件处理程序会按照添加它们的顺序触发。通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法被移除。例：123var btn = document.getElementById("myBtn");btn.addEventListener('click', function () &#123;alert(this.id)&#125;, false)btn.removeEventListener('click', function () &#123;alert(this.id)&#125;, false) 在这个例子中，我们使用 addEventListener()添加了一个事件处理程序。虽然调用 removeEventListener()时看似使用了相同的参数，但实际上，第二个参数与传入 addEventListener()中的那一个是完全不同的函数。而传入 removeEventListener()中的事件处理程序函数必须与传入 addEventListener()中的相同，如下面的例子所示:1234var btn = document.getElementById("myBtn");var handler = function () &#123;alert(this.id)&#125;btn.addEventListener('click', handler, false);btn.removeEventListener('click', hanler, false); // 有效 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 13.2.4 IE事件处理程序 IE实现了与DOM类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数通过attachEvent()添加的事件处理程序都会被添加到事件冒泡阶段。例：12var btn = document.getElementById("myBtn");btn.attachEvent('onclick', function () &#123;alert('Clicked')&#125;) 注： attachEvent()的第一个参数是”onclick”，而非 DOM的 addEventListener()方法中 的”click”在 IE 中使用 attachEvent()与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。例：12var btn = document.getElementById("myBtn");btn.attachEvent('onclick', function () &#123;alert(this === window)&#125;) // true 与 addEventListener()类似，attachEvent()方法也可以用来为一个元素添加多个事件处理程 序。例:123var btn = document.getElementById("myBtn");btn.attachEvent("onclick", function()&#123;alert("Clicked");&#125;);btn.attachEvent("onclick", function()&#123;alert("Hello world!");&#125;); 这里调用了两次 attachEvent()，为同一个按钮添加了两个不同的事件处理程序。不过，与 DOM 方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。单击这个例子中的按钮，首先看到的是”Hello world!”，然后才是”Clicked”。 使用 attachEvent()添加的事件可以通过 detachEvent()来移除，条件是必须提供相同的参数。1234var btn = document.getElementById("myBtn");var handler = function () &#123;alert('Clicked')&#125;;btn.attachEvent("onclick", handler);btn.detachEvent("onclick", handler); 13.3 事件对象在触发DOM上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。 13.3.1 DOM中的事件对象 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。例：123var btn = document.getElementById('myBtn');btn.onclick = function (event) &#123;alert(event.type)&#125;; // "click"btn.addEventListener('click', function (event) &#123;alert(event.type)&#125;, false); // "click" 在通过 HTML特性指定事件处理程序时，变量 event 中保存着 event 对象。在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this、currentTarget 和 target 包含相同 的值。例：1234var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123;alert(event.currentTarget === this); // truealert(event.target === this); // true &#125; 事件注册到了button上,所以this，currentTarget、target三者相等。如果事件处理程序存在于按钮的父节点中（例如 document.body），那么这些值是不相同的。例：123456var btn = document.getElementById("myBtn");document.body.onclick = function (event) &#123; alert(event.currentTarget === document.body); // true alert(this === document.body); // true alert(event.target === btn); // true&#125; 当单击这个例子中的按钮时，this 和 currentTarget 都等于 document.body，因为事件处理程 序是注册到这个元素上的。然而，target元素却等于按钮元素，因为它是 click 事件真正的目标。由于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了document.body，在那里事件才得到了处理。要阻止特定事件的默认行为，可以使用preventDefault()方法，例如，链接的默认行为就是在 被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 onclick 事件处理程序可以取消它。1234var link = document.getElementById("myLink");link.onclick = function (event) &#123; event.preventDefault()&#125; 只有 cancelable 属性设置为 true 的事件，才可以使用 preventDefault()来取消其默认行为。另外，stopPropagation()方法用于立即停止事件在DOM层次中传播，即取消事件的捕获或冒泡。例：12345678var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert("Clicked"); event.stopPropagation();&#125;; document.body.onclick = function(event)&#123; alert("Body clicked"); &#125; 事件只会作用在btn上，不会传播到document.body，因此就不会触发注册在这个元素上的 onclick 事件处理程序。事件对象eventPhase属性，可以确定当前事件流处在那个阶段。如果是捕获阶段，那么eventPhase = 1; 事件处理位于目标对象上，eventPhase = 2; 如果事件处理程序，位于冒泡阶段，则eventPhase = 3; 注： 只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完 成，event 对象就会被销毁 13.3.2 IE中的事件对象 1.DOM0级event做为window对象的一个属性存在。例：12345var btn = document.getElementById("myBtn");btn.onclick = function () &#123; var event = window.event; alert(event.type)&#125; 2.如果事件处理程序使用attachEvent()添加，那就会有一个event对象做为参数传入事件处理程序函数中。例：1234var btn = document.getElementById("myBtn");btn.attachEvent('onclick', function (event) &#123; alert(event.type)&#125;) IE中，event对象包含创建它事件的属性和方法，cancelBubble设置为true时，可以取消事件冒泡（同DOM中的stopPropagaion()方法作用相同）；returnValue,设置为false时，就可以取消事件的默认行为（与DOM中的PreventDefault()方法作用域相同），srcElement与DOM中的target相同，指向事件的目标对象，type就是事件类型。例：12345678910var link = document.getElementById("myLink");link.onclick = function()&#123; window.event.returnValue = false;&#125;;// cancelBubble与stopPropagation()相同，阻止事件冒泡（由于IE浏览器没有事件捕获），但时stopPropagation()可以同时阻止事件捕获和冒泡。var btn = document.getElementById("myBtn");btn.onclick = function () &#123; var event = window.event; event.cancelBubble = true;&#125; 13.4 事件类型]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>-javascript -summarize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InterView]]></title>
    <url>%2F2019%2F02%2F22%2FInterView%2F</url>
    <content type="text"><![CDATA[函数节流(throttle)和防抖(debounce)1.函数防抖 触发高频事件后n秒内函数只执行一次，如果n秒内高频事件再次触发，则重新计算触发时间。 2.函数节流 高频事件触发,但在n秒内只会执行一次，所以节流会稀释函数的执行频率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//立即执行的防抖函数，常用于防止短时间内多次点击按钮，调用接口。function now()&#123; //用来获取当前时间戳 return +new Date()&#125;/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce(func, wait = 50, immediate = true)&#123; let timer, context, args; //延迟执行函数(当在搜索引擎搜索问题时，肯定希望输入完成以后才调用接口，这时候执行延迟的防抖函数) const later = () =&gt; setTimeout(() =&gt; &#123; //延迟执行函数执行完毕，清除缓存的定时器序列号 timer = null //延迟执行的情况下，函数会在延迟函数中执行 //使用到之前缓存的参数和指向上下文 if(!immediate) &#123; func(context, args) context = args = null &#125; &#125;, wait) //这里返回的函数是实际每次调用的函数 return function(...params)&#123; //如果没有创建延迟函数就创建一个 if(!timer) &#123; timer = later() if(immediate) &#123; //如果是立即执行，调用函数 //否则缓存参数和调用上下文 func.apply(this, params) &#125; else &#123; context = this args = params &#125; //如果已有延迟函数(later),调用的时候清除原来的并重新设定一个 //这样做延迟函数会重新计时 &#125; else &#123; clearTimeout(timer) timer = later() &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;object&#125; options 如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。 * 如果想忽略结尾函数的调用，传入&#123;trailing: false&#125; * 两者不能共存，否则函数不能执行 * @return &#123;function&#125; 返回客户调用函数 */_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = &#123;&#125;; // 定时器回调函数 var later = function() &#123; // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>summarize</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-summarize2]]></title>
    <url>%2F2019%2F01%2F02%2Fjs-summarize2%2F</url>
    <content type="text"><![CDATA[写在前面：本文是JavaScript高级程序设计内容的总结汇总，便于备忘，用于提升！第6章 面向对象程序设计 6.1 理解对象 创建一个对象最简单的办法就是创建一个Object实例，然后再为它添加属性和方法。例：1234567891011121314151617var person = new Object();person.name = "Nicholas";person.age = 29;person.job = "Software Enginner";person.sayName = function()&#123; alert(this.name)&#125;//对象字面量写法：var person = &#123; name: "Nicholas", age: 29, job: "Software Enginner", sayName: function()&#123; alert(this.name) &#125;&#125; 6.1.1 属性类型 ECMAScript中有两种属性：数据属性和访问器属性。 1 数据属性 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。 [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为true。 [[Enumerable]]: 表示能否通过for-in循环返回属性。默认值为true。 [[Writable]]: 表示能否修改属性的值。默认值为true。 [[Value]]: 包含这个属性的数据值。这个特性的默认值是undefined。 要修改属性默认特性，必须使用ECMAScript5的Object.defineProperty()方法。方法接收三个参数：属性所在对象、属性名和一个描述符对象。其中，描述符对象必须是：configurable、enumerable、writeable和value。设置其中一或多个值，可以修改对应的特性值。例：123456789var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, value: "Nicholas"&#125;);alert(person.name); //"Nicholas"person.name = "Greg";alert(person.name); //"Nicholas" 2 访问器属性 [[Configurable]]: 同上。 [[Enumerable]]: 同上。 [[Get]]: 在读取属性时调用的函数。默认值undefined。 [[Set]]: 在写入属性时调用的函数。默认值undefined。 访问器属性不能直接定义，必须使用ECMAScript5的Object.defineProperty()定义。例：123456789101112131415161718var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, "year", &#123; get: function()&#123; return this._year &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 6.1.2 定义多个属性 ECMAScript又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个参数：第一个对象是要添加和修改其属性的对象。第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例：1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;) 6.1.3 读取属性的特性 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在对象和要读取其描述符的属性名称。返回值是一个对象。如果是访问器属性，这个对象属性有configurable、enumerable、get和set;如果是数据属性，这个对象属性有configurable、enumerable、writable和value，例：123456789101112131415161718192021222324252627282930var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;)var descriptor = Object.getOwnPropertyDescriptor(book, "_year");alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, "year");alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //"function" 6.2 创建对象 6.2.1 工厂模式123456789101112function createPeson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o;&#125;var person = createPerson("Greg", 27, "Doctor"); 6.2.2 构造函数模式1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person1 = new Person("Greg", 27, "Doctor");var person2 = new Person("jim", 29, "Software Enginner"); 构造函数始终都应该以一个大写字母开头，非构造函数以小写字母开头。创建person新实例，必须使用new操作符，经历4个步骤： 1. 创建一个新对象 2. 将构造函数的作用域赋给新对象(因此this就指向了这个新对象); 3. 执行构造函数中的代码(为新对象添加属性); 4. 返回新对象。 创建自定义构造函数可以将它的实例标识为一种特定类型，这是构造函数模式胜过工厂模式的地方。 构造函数问题缺点就是每个方法都要在实例上重新构建一遍，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。如下：12345678function Person(name, age, job)&#123; this.name = name; this.job = job; this.sayName = new Fuction("alert(this.name)"); //与声明函数在逻辑上是等价的&#125;//这样看更容易理解每个Person实例都包含一个不同的Fuction实例。一下代码可以证明：alert(person1.sayName == person2.sayName); //false 6.2.3 原型模式 每个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。例：12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name)&#125;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //true 1. 理解原型对象 ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，这个方法返回[[Prototype]]（实例的内部属性，指向原型对象）的值。例:12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //"Nicholas" 2. 原型与in操作符 无论属性存在于实例中还是存在于原型中。同时使用hasOwnPrototype()方法和in操作符,就可以确定该属性到底存在于对象中还是存在于原型中。如下：12345function hasPrototypeProperty(Object, name)&#123; return !Object.hasOwnProperty(name) &amp;&amp; (name in Object)&#125;//返回true则存在于原型中，false则存在于实例中 要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：12345678910111213141516function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;var keys = Object.keys(Person.prototype);alert(keys); //"name, age, job, sayName"var person1 = new Person();person1.name = "Rob";person1.age = 31;var p1keys = Object.keys(p1);alert(p1keys); //"name,age" 如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。例：12var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor, name, job, sayName" 3. 更简单的原型语法 前面每个例子中都需要敲一遍Person.prototype,为减少不必要输入，可以用对象字面量来重写整个原型对象123456789function Person()&#123;&#125; Person.prototype = &#123; name: 'Nicholas', age: 29, job: "Software Enginner", sayName: function () &#123; alert(this.name) &#125;&#125; 最终结果相同，但是有一个例外就是constructor属性不在指向Person了123var friend = new Person()alert(friend.constructor == Person) //falsealert(friend.constructor == Object) //true 如果constructor值很重要，则可以这样特意将它设置回适当的值。12345678910function Person()&#123;&#125; Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: "Software Enginner", sayName: function () &#123; alert(this.name) &#125;&#125; 注： 这样设置的constructor属性，会导致它的[[Enumberable]]特性设置为true，默认情况下，原生的为false，因此如果使用可以兼容ECMAScript5的JavaScript引擎，可以使用Object.defineProperty()设置1234567891011121314function Person()&#123;&#125; Person.prototype = &#123; name: 'Nicholas', age: 29, job: "Software Enginner", sayName: function () &#123; alert(this.name) &#125;&#125;// 重设构造函数，只适用于ECMAScript5兼容的浏览器Object.defineProperty(Person.prototype, 'constructor', &#123; value: Person, enumerable: false&#125;) 4. 原型的动态属性12345678910111213141516171819202122var friend = new Person()Person.prototype.sayHi = function()&#123; alert("hi")&#125;friend.sayHi() //"hi" ("没有问题")// 但是如果将原型对象重新写的话，那么就等于把原型修改为另外一个对象，相当于切断了构造函数与最初原型的联系。例：function Person() &#123;&#125;var friend = new Person()Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: "Software Enginner", sayName: function () &#123; alert(this.name) &#125;&#125;friend.sayName(); //error 5. 原生对象的原型 Array、String、Object等原生引用类型都在其构造函数的原型上定义了方法。例12345678910alert(typeof Array.prototype.sort) //"function"alert(typeof String.prototype.subString) ////"function"//通过原生对象的原型也可以定义新方法，下面代码就是给基本包装类型String添加startsWith()方法，但不建议修改原生引用上的方法，容易导致不必要的错误String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;var msg = "Hello World";alert(msg.startsWith("Hello")); //true 6. 原型对象的问题 原型中所有属性是被实例共享的，这种共享对函数来说很合适，对于包含基本属性值的属性也说的过去，但对于包含引用类型值的属性来说，问题就比较突出了。例：12345678910111213141516171819function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'Nicholas', age: 29, job: "Software Enginner", friends: ["Lily", "Court"], sayName: function () &#123; alert(this.name) &#125;&#125;var person1 = new Person();var person2 = new Person();person1.friends.push("Van");alert(person1.friends); //["Lily", "Court", "Van"]alert(person2.friends); //["Lily", "Court", "Van"]alert(person1.friends === person2.friends); //true 6.2.4 组合使用构造函数模式和原型模式 创建自定义类型最常见方式。就是组合使用构造函数模式与原型模式。构造函数，模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样每个实例都有自己的一份实例属性副本，同时又共享着对方法的引用，最大限度地节省了内存。另外这种混合组成模式还支持向构造函数传递参数。例：1234567891011121314151617181920function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["Lily", "joe"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name) &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Enginner");var person2 = new Person("Gerg", 27, "Doctor");person1.friends.push("Van");alert(person1.friends); //"Lily, joe, Van"alert(person2.friends); //"Lily, joe" 6.3 继承 ECMAScript实现继承主要是依靠原型链来实现。 6.3.1 原型链 将原型对象等于另一个类型的实例，此时原型对象将包含另一个指向另一个原型的指针。例：123456789101112131415161718192021function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue); //true//注：此时instance。constructor指向的是SuperType,因为原来SubType.prototype中的constructor被重写了 1 所有引用类型的默认都继承了Object,这个继承也是通过原型链实现的。 2 确定原型和实例的关系123456789// 1. instanceof操作符 用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回truealert(instance instanceof Object); //truealert(instance instanceof SubType); //truealert(instance instanceof SuperType); //true// 2. isPrototypeOf()方法alert(Object.prototype.isPrototypeOf(instance)); //truealert(SubType.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //true 3 定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法，不管怎样，给原型添加方法代码一定要放在替换原型语句之后。例：1234567891011121314151617181920212223function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.prototype;&#125;function SubType()&#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();// 添加新方法SubType.prototype.getSubValue = function()&#123; return this.subproperty&#125;//修改超类型中的方法SubType.prototype.getSuperValue = function()&#123; return false;&#125;var instance = new SubType();alert(instance.getSuperValue()); //false//注：重写原型链中存在的方法，会屏蔽掉原来的方法。即当使用SubType的实例调用getSuperValue()时，调用的就是重新定义的方法。通过SuperType实例调用的getSuperValue()时，还会调用原来的方法。 3 原型链的问题 同原型问题一样，在包含引用类型的原型属性调用时就会出问题。例12345678910111213function SuperType()&#123; this.color = ["red", "green", "blue"]&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType()var instance1 = new SubType();instance1.color.push("black");alert(instance1.color); //"red, green, blue, black"var instance2 = new SubType();alert(instance2.color); //"red, green, blue, black" 6.3.2 借用构造函数12345678910111213141516function SuperType()&#123; this.colors = ["red","blue","green"]&#125;function SubType()&#123; //继承了SuperType SuperType.call(this)&#125;var instance1 = new SubType()instance1.colors.push("black")alert(instance1.colors); //"red, blue, green, black"var instance2 = new SubType()alert(instance2.colors); //"red, blue, green"//在新创建的SubType实例的环境下调用SuperType构造函数。这样一来就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。 1 传递参数123456789101112function SuperType(name)&#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, 'Nicholas'); this.age = 29;&#125;var instance = new SubType()alert(instance.name); //Nicholasalert(instance.age); //29//在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置name属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再在子类型中添加定义的属性。 2 借用构造函数的问题 仅仅调用构造函数就会同构造函数模式存在的问题相同—方法都在构造函数中定义，因此函数复用就无从谈起。 6.3.3 组合继承 组合继承有时候也称为伪经典继承，指的是将原型链和构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。例：1234567891011121314151617181920212223242526272829303132function SuperType(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name)&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age)&#125;var instance1 = new SubType("Nicholas",29);instance1.colors.push("black");alert(instance1.colors) //"red, blue, green, black"instance1.sayName(); //"Nicholas"instance1.sayAge(); //29var instance2 = new SubType("Gerg", 27);alert(instance2.colors) //"red, blue, green"instance2.sayName(); //"Gerg"instance2.sayAge(); //27//javascript中最常用的继承模式 6.3.4 寄生组合继承 组合继承也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次在创建子类型原型的时候，另一次是在子类型构造函数内部。例：12345678910111213141516171819202122function SuperType(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); //第二次调用SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); //第一次调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;/*第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors。它们都是SuperType的实例(原型对象)属性，只不过现在位于SubType的原型中。当调用SubType构造函数时,又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中两个同名属性。*/ 解决办法：寄生组合式继承模式如下：123456789101112131415161718192021222324252627282930313233function inheritPrototype(subType, superType) &#123; var prototype = Object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;inheritPrototype()/*函数实现了寄生组合继承最简单形式。这个函数接收两个参数：子类型的构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二个是为创建的副本添加constructor属性，弥补因重写原型而失去的默认的constructor属性。最后一步将新创建的对象(即副本)赋值给子类型的原型。*/function SuperType(name) &#123; this.name = name; this.colors = ["red","blue","green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name, age) &#123; SuperType.call(this.name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;/*只调用了一次SuperType构造函数，避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链保持不变，还能够正常使用instanceof和isPrototypeOf()。普遍认为寄生组合是引用类型最理想的继承范式。*/ 第7章 函数表达式定义函数有两种形式：函数声明和函数表达式。 7.1 递归 递归函数是在一个函数通过名字调用自身的情况下构成的，例：1234567891011121314151617181920212223242526272829function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * factorial(num - 1) &#125;&#125;/*一下代码会导致上面代码出错var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4))当调用anotherFactorial()时，由于必须执行factorial(),而factorial已经不再是函数，所以导致错误。*///arguments.callee指向正在执行的函数的指针，也可以使用下面这样，但是在严格模式下无效function factorial(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1) &#125; &#125;//可以通过使用命名函数表达式来达成相同结果var factorial = (function f(num) &#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num - 1) &#125;&#125;) 7.2 闭包 有权访问另一个函数作用域中的变量的函数。常见方式就是在函数内部创建另一个函数。例1234567891011121314function createComparisonFunction(properyName)&#123; return function(object1, object2) &#123; var value1 = object1[properyName]; var value2 = object2[properyName]; if (value1 &lt; value2) &#123; return -1 &#125; else if(value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125; &#125;&#125;//返回的匿名函数中引用了createComparisonFunction函数的变量properyName，这就是形成了闭包。 7.2.1 闭包与变量 作用域链的这种配置机制引出了一个问题，即闭包只能取得包含在函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。例：123456789101112131415161718192021222324function createFunctions()&#123; var result = new Array(); for(var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i &#125; &#125; return result&#125;/*返回一个函数数组[ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ, ƒ]，因为每个函数作用域链中都保存着createFunctions()函数的活动对象，所以引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值为10。此时每个函数都引用着保存变量i的同一个变量对象，所以每个函数内部i的值都是10*/function createFunctions()&#123; var result = new Array(); for(var i=0; i &lt; 10; i++)&#123; result[i] = (function(num)&#123; return num &#125;)(i) &#125; return result&#125;//调用匿名函数时，传入变量i。由于函数按值传递，所以变量i的当前值复制给参数num。 7.2.2 关于this对象 this对象是在运行时基于函数的执行环境绑定的。在全局函数中，this等于window，当函数最为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window(在通过call或apply改变函数的执行环境的情况下，this就会指向其他对象)。但有时候，这一点可能不会那么明显。例：12345678910111213141516171819202122232425262728293031323334var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;alert(object.getNameFunc()()); //"The Window"//为什么会是The Window呢？/*每个函数在被调用时都会自动取得两个特殊变量:this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象(因为包含自己的作用域有，就不会在到包含的外部作用域找)，因此永远不可能直接访问外部函数中的这两个变量。*///把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function()&#123; var that = this; return function()&#123; return that.name &#125; &#125;&#125;alert(object.getNameFunc()()); //"My Object"/*在定义匿名函数之前，把this对象赋值给了一个名叫that的变量。在定义闭包之后，闭包可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object,所以调用object.getNameFunc()()返回了"My Object"*/ 第8章 BOMECMAscript是JavaScript的核心，但是要在Web中使用Javascript，那么BOM(浏览器对象模型)则无疑是真正的核心。 8.1 window对象 BOM的核心对象是window，它表示浏览器的一个实例，在浏览器中，window对象即是通过JavaScript访问浏览器窗口的一个接口，又是ECMAscript规定的Global对象。 8.1.1 全局作用域 window对象同时扮演着ECMAscript中Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例:123456789var age = 29;function sayAge()&#123; alert(this.age);&#125;alert(window.age); //29sayAge(); //29window.sayAge(); //29//在全局作用域中定义的变量age和函数sayAge()，它们自动归在了window对象名下。由于sayAge()存在于全局作用域中，因此this.age别映射到window.age。 定义在全局变量和直接定义在window对象上的属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可。例：12345678910111213var age = 29;window.color = "red";//在IE &lt; 9 时抛出错误，在其他浏览器都返回falsedelete window.age //在IE &lt; 9 时抛出错误，在其他浏览器都返回truedelete window.coloralert(window.age); //29alert(window.color); //undefined/*使用var语句添加的window属性有一个名为[[Configurable]]的特性，这个特性的值被设置为false,因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本使用delete删除window属性的语句时，不管如何创建都会抛出错误。*/ 另外尝试访问未声明的变量会抛出错误，但通过查询window对象，可以知道某个可能未声明的变量是否存在。例：12var newValue = oldValue; //报错，因为oldValue未定义var newValue = window.oldValue; //不报错，因为这是一次查询 8.1.3 窗口位置 用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera 和 Chrome都提供了screenLeft 和 screenTop属性，分别表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。12345//下面代码可以跨浏览器获取窗口上边和左边的位置var leftPos = (typeof window.screenLeft === 'number') ? window.screenLeft : window.screenXvar topPos = (typeof window.screenTop === 'number') ? window.screenTop : window.screenY 注：Firefox、Safari 和 Chrome 始终返回页面中每个框架的 top.screenX 和top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于 window 对象使用screenX 和 screenY 每次也都会返回相同的值。而 IE 和 Opera 则会给出框架相对于屏幕边界的精确坐标值。最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。 8.1.4 窗口大小 IE9+、Firefox、Safari、Opera 和 Chrome 均为此提供了 4 个属性：innerWidth、innerHeight、outerWidth 和 outerHeight。在 IE9+、Safari 和 Firefox中，outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的 window 对象还是从某个框架访问）。在 Opera中，这两个属性的值表示页面视图容器的大小。而 innerWidth 和 innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在 Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。123456789101112//获取浏览器视口var pageWidth = window.innerWidth;var pageHeight = window.innerHeight;if (typeof pageWidth !== 'number') &#123; if (document.compatMode == "CSS1Compat") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 8.1.5 导航和打开窗口 window.open(),接受四个参数：要加载的URl、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值 8.2 location对象 location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象。1window.location === document.location //true 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟零或多个字符），如果中不包含散列，则返回空字符串 host “www.wrox.com:80&quot; 返回服务器名称和端口号（如果有） hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 返回当前加载页面的完整URL。而location对toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的目录和（或）文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口这个属性返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>summarize</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-summarize]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文是基于JavaScript高级程序设计内容的一个总结，算作读书笔记？或者是备忘，也算是一种总结，希望能掌握一些基础的知识，更有利于以后的学习开发。与君共勉！Javascript诞生于1995年, 当时就职于Netscape 公司的布兰登·艾奇,计划于1995年2月发布由Netscape Navigator 2开发的脚本语音LiveScript,为了赶在发布日期之前，Netscape与Sun公司建立了一个开发联盟。在Netscape Navigator 发布前夕，Netscape为了搭载上热炒Java的顺风车，临时把LiveScript 改为 JavaScript。 Javascript 是一种专为与网页交互而设计的脚本语言，由以下三部分组成: ECMAScript，由ECMA-262定义，提供核心语言功能 文档对象模型（DOM）,提供访问和操作网页内容的方法和接口 浏览器对象模型（BOM）,提供与浏览器接口交互的方法和接口 在HTML中使用JavaScript &lt;script&gt;元素 &lt;script&gt;定义了6个属性 async: 可选 表示应该立即下载脚本，但不妨碍页面其他操作，只对外部脚本文件有效，不能保证异步脚本按照它们在页面的顺序执行 charset: 可选。 defer: 可选。表示脚本可以延迟到文档被完全解析后再执行。只对外部脚本文件有效，最好只包含一个延迟脚本，延迟脚本总是按照指定它们的顺序执行 language: 已废弃 src: 表示要引用的外部文件 type: 可选。表示编写代码使用的脚本语言的内容类型 &lt;noscript&gt;元素 在&lt;noscript&gt;中的内容在下面两种情况下才显示出来 浏览器不支持脚本 浏览器支持脚本，但被禁用 JavaScript将被从上到下依次执行,在所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载显示，在不使用defer和async的情况下 基本概念 1. 语法 1.1 区分大小写 ECMAScript中的一切(变量、函数名和操作符)都区分大小写 1.2 标识符 标识符 就是指变量、函数、属性的名字或者函数的参数。标识符规则如下 1 第一个字符必须是字母、下划线 或 $ 2 其他字符可以是字母、数字、下划线 或 $ 按照惯例，ECMAScript采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写，如：firstSecond myCar 1.3 注释 // 单行注释 /* 这是一行多行注释 */ 1.4 严格模式 ECMAScript5引入严格模式，严格模式是为JavaScript定义了一种不同的解析与执行模型。要在整个模式启用严格模式，可以在顶部添加如下代码： “use strict” 1.5 语句 ECMAScript中的语句以一个分号结尾；虽然语句的分号不是必需的，但建议任何时候都不要省略它。 2. 数据类型 ECMAScript中有五种基本操作类型: Number、String、Bollean、Null、Undefined，还有一种复杂的数据类型Object。ECMAScript不支持任何创建自定义类型的机制，所有值最终将是上述6中类型之一。 2.1 typeof操作符 使用typeof检测数据类型，使用typeof操作符返回下列某个字符串： 1. “undefined”: 如果这个值未定义； 2. “boolean”: 如果这个值是布尔值； 3. “string”: 如果这个值是字符串； 4. “number”: 如果这个值是数字； 5. “object”: 如果这个值是对象或者null； 6. “function”: 如果这个值是函数 2.2 Undefined类型 在使用var声明变量但未对其初始化时,这个变量的值就是undefined,例如:12var message; //只定义了变量，未初始化变量alert(message === undefined) //true 注： 未声明的变量执行typeof也会返回undefined,初始化声明的变量是明智的选择。 2.3 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊值是null。从逻辑角度看，null表示一个空对象指针，而这也正是使用typeof操作符检测null值时返回”object”的原因。 实际上，undefined值是派生自null值的，因此ECMA-262规定对他们的相等性检测返回true1alert(null == undefined) // true 2.4 Bollean类型 该类型只有两个字面值：true和false 2.5 Number类型 这种类型使用IEEE754格式来表示整数和浮点数组。 最基本的数值字面量格式是十进制整数。如 var intNum = 55; //整数 除十进制表示外，整数还有八进制和十六进制，其中八进制第一位必须是零，然后八进制数字序列(0~7),如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值当作十进制数值解析。123 var octalNum1 = 070; //八进制的56 var octalNum2 = 079; //无效的八进制数值,解析为79 var octalNum3 = 08; //无效的八进制数值，解析为8 注： 八进制字面量在严格模式下是无效的。 十六进制字面量的前两位必须是0x,后跟任何十六进制数字(0~9及A~F)。其中可以大写，也可以小写。12var hexNum1 = 0xA; //十六进制的10var hexNum2 = 0x1f; //十六进制的31 2.5.1 数值范围 ECMAScript 能够保存的最小值保存在 Number.MIN_VALUE中，在大多数浏览器中这个数是5e-324。超过这个数值，则会被转换为-Infinity(负无穷)；最大值保存在Number.MAX_VALUE中，在大多数浏览器中这个数是1.7976931348623157e+308。超过这个数值，则会被转换为Infinity(正无穷) 2.5.2 NaN NaN，非数值(Not a Number) 是一个特殊的数值，这个数值表示一个本来要返回数值的操作数未返回数值的情况(这样就不抛出错误了)。例如: 任何数值除以0都会导致错误，但在ECMAScript中，任何数值除以0会返回NaN,不影响代码执行。 NaN两个特点: 1. 任何涉及NaN的操作(例如：NaN/10)都会返回NaN,在多步计算中可能导致问题。2. NaN与任何值都不相等，包括NaN本身。 ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型的数据，而函数会帮我们确定该参数是否”不是数值”12345isNaN(NaN) //trueisNaN(10) //false (10是一个数值)isNaN("10") //false (可以被转换成数值10)isNaN("blue") //true (不能转换成数值)isNaN("true") //false (可以被转换成数值1) 注: 实际上只有0除以0才会返回NaN，正数除以0返回Infinity,负数除以0返回-Infinity 2.5.3 数值转换 Number()、parseInt()、parseFloat()可以把非数值转换为数值。其中Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有不同的返回结果。 Number()函数转换规则如下。 1. 如果是Boolean值，true和false将分别被转换为1和0 2. 数字值，只是简单的传入和返回。 3. null值，返回0。 4. undefined，返回NaN。 5. 如果是字符串，遵循下列规则: 1 如果字符串只包含数字，则将其转换为十进制数值 2 如果包含有效的浮点格式数据，则将其转换为对应的浮点数值。 3 如果包含有效的十六进制数据，则将其转换为相同大小的十进制整数值。 4 如果字符串为空，则将其转换为0。 5 如果字符串包含除上述以外的字符，则将其转换为NaN。 6. 如果是对象，则调用对象的valueOf()方法，然后按照前面规则转换返回的值。如果转换结果为NaN,则调用对象的toString()方法，然后再按照前面的规则转换返回的字符串值。1234Number('hello world') // NaNNumber(" ") // 0Number("00011") // 11Number(true) // 1 处理整数的时候更常用的是parseInt()函数。parseInt(string)函数规则如下： 1. 字符串第一个不是数字字符或者负号，parseInt()返回NaN,也就是说parseInt()转换空字符串也会返回NaN。 2. 如果第一个字符是字符串，则直到解析完后续的字符或者遇到了一个非数字字符。例如，”1234blue”会被转会为1234，类似的”22.5”会被转换为22，因为小数点并不是有效的数字字符。 3. 同样的parseInt()也能识别各种整数格式(即十进制、八进制、十六进制)，如果字符串以”0x”开头且后跟数字字符，就会将其当作十六进制整数；如果字符串以”0”开头且后跟数字字符，则会当作八进制数来解析。1234567parseInt("1234blue"); //1234parseInt(""); //NaNparseInt("0xA"); //10parseInt("22.5"); //22parseInt("070"); //56parseInt("70"); //70parseInt("0xf"); //15 可以为函数提供第二个参数:转换时使用的基数(即多少进制)，例如：123parseInt("0xAF", 16); //175parseInt("AF", 16); //175parseInt("AF"); //NaN 指定基数会影响到转换的输出结果。例如：1234parseInt("10", 2) //2 (按二进制解析)parseInt("10", 8) //8 (按八进制解析)parseInt("10", 10) //10 (按十进制解析)parseInt("10", 16) //16 (按十六进制解析) parseFloat(string)函数规则: 1. 与parseInt()函数类似，直到解析遇到无效的浮点数字字符为止。字符串中的第一个小数点是有效的，第二个小数点是无效的。例，”22.34.5”将会被转换为22.34 2. parseFloat()会忽略前导零。十六进制的字符串始终会被转换为0。parseFloat()只解析十进制数值。因此没有用第二个参数指定基数的用法。123456parseFloat("1234blue"); //1234parseFloat("0xA"); //0parseFloat("22.5"); //22.5parseFloat("22.34.5"); //22.34parseFloat("0908.5"); //908.5parseFloat("3.125e7"); //31250000 2.6 String类型 String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。 2.6.1 转换为字符串 方法一：toString()1234var age = 11;age.toString(); //字符串"11"var found = true;found.toString(); //字符串"true" 数值、布尔值、对象和字符串值都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是调用数值的toString()的方法时，可以传递一个参数：输出数值的基数。123456var num = 10;num.toString(); //"10"num.toString("2"); //"1010"num.toString("10"); //"10"num.toString("8"); //"12"num.toString("16"); //"a" 注： 默认(没有参数的)输出值与指定基数10时的输出值相同 方法二：string() 在不知道数值数是不是null或undefined的情况下，可以使用转型函数string();这个函数能够将任何类型的值转换为字符串。转换规则如下： 1 如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果。 2 如果值是null,则返回”null”。 3 如果值是undefined，则返回”undefined”123456789var value1 = 10;var value2 = true;var value3 = null;var value4;String(value1); //"10"String(value2); //"true"String(value3); //"null"String(value4); //"undefined" 2.7 Object类型 ECMAScript中的对象就是一组数据和功能的集合。对象可以执行new操作符后跟要创建的对象类型的名称来创建。如: var o = new Object(); Object类型是所有它的实例的基础。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object每个实例都具有下列属性和方法： 1 constructor: 保存着用于创建当前对象的函数。对前面例子而言，构造函数(constructor)就是Object(); 2 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。作为参数的属性名(propertyName)必须以字符串的形式指定。(例如：o.hasOwnProperty(“name”)) 3 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型。 4 propertyIsEnumerable(propertyName): 用于检查给定的属性是否能用for-in语句来枚举。作为参数的函数名必须以字符串形式指定。 5 toLocalString(): 返回对象的字符串表示，该字符传与执行环境的地区对应。 6 toString(): 返回对象的字符串表示。 7 valueOf(): 返回对象的字符串、布尔值或数值表示。 3. 语句 3.1 if 语句 3.2 do-while 语句 在对条件表达式求值之前，循环体内的代码最少会被执行一次。1234var i = 0;do &#123; i += 2;&#125; while(i &lt; 10) 3.3 while 语句 while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。1234var i = 0;while ( i &lt; 10) &#123; i += 2;&#125; 3.4 for 语句 3.5 for-in 语句 for-in语句是一种精准的迭代语句，用来枚举对象的属性。for-in语句的语法： for(property in expression) statement123for (var propName in window) &#123; document.write(propName)&#125; 3.5 switch 语句123456789switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; ECMAScript中的switch语句，可以在switch中使用任何类型的数据，其次case不一定是常量，可以是变量，甚至是表达式。例12345678910switch('hello world') &#123; case: "hello" + "world": alert("Greeting was found"); break; case: "goodbye": alert("Closing was found"); break; default: alert("Unexpected message was found");&#125; 3.6 函数 ECMAScript中使用function关键字来声明,后跟一组参数以及函数体。 function functionName(arg0, arg1,…,argN) { statements } ECMAScript 中的函数在定义时不必指定是否返回返回值。函数执行完return语句后停止并立即退出。return语句可以不带任何返回值，这种情况下，函数停止执行后返回undefined。 3.6.1 理解参数 ECMAScript函数对参数数量和数据类型无限制，原因是ECMAScript中的参数在内部用一个数组来表示。实际上，在函数体内通过arguments对象来访问这个数组。使用length属性来确定传递进来多少个参数。(arguments对象只是与数组类似，并不是Array的实例)。arguments对象可以与命名参数一起使用。如：1234567function (num1, num2) &#123; if (arguments.length == 1) &#123; alert(num1 + 10) &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + num2) &#125;&#125; arguments的值永远与对应命名参数的值保持同步。arguments对象的长度由传入参数的个数决定，不是由定义函数时的命名参数的个数决定的。 注： 没有传递值的命名参数将自动被赋予undefined值。这就跟定义了没有初始化一样。 3.7 没有重载 ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，则该名字只属于后定义的函数。例：123456789function addsomeNumber(num) &#123; return num + 100&#125;function addsomeNumber(num) &#123; return num + 200&#125;var result = addsomeNumber(100) 返回结果是300，后定义的会覆盖先定义的函数。 变量、作用域、内存问题ECMAScript变量包含基本类型值和引用类型值，基本类型的值是按值访问的，因此可以操作保存在变量中的实际值，引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 注： 当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际对象 4.1.1 动态的属性 对于引用类型的值，我们可以为其添加属性和方法，也可以删除和改变其属性和方法。123var person = new Object();person.age = 18;alert(person.age); //18 不能给基本类型值添加属性，只能给引用类型值添加属性。 4.1.2 复制变量值 基本数据类型值的变量的复制会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。这两个变量可以参与任何操作而不会相互影响。 变量复制引用类型的值时，也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针。而这个指针指向存储在堆中的一个对象。两个变量实际上引用的是同一个对象。改变其中一个变量，也会影响另一个变量。例：1234var obj1 = new Object();var obj2 = obj1;obj1.name = "Nicholas"alert(obj2.name) //Nicholas 4.1.3 传递参数 ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 在向参数传递基本数值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量会反映在函数的外部。12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);alert(count); //20,没有变化alert(result); //30 如果使用对象，再举一个例子：1234567function setName(obj) &#123; obj.name = 'jim'&#125;var person = new Object();setName(person);alert(person.name) //"jim" 为了证明对象是按值传递的，再看一下经过修改的例子：12345678function setName(obj) &#123; obj.name = "jim"; obj = new Object(); obj.name = "Greg";&#125;var person = new Object();setName(person);alert(person.name); //"jim" 如果person是按引用传递的，那么person就会自动修改为指向其name属性值为”Greg”的新对象。但是实际是没有变，仍为”jim”。实际上，当函数内部重写obj时，这个变量引用的就是一个局部对象了。这个局部对象会在函数执行完毕后立即被销毁。 4.1.4 检测类型 检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，用处不大。 ECMAScript提供了instanceof操作符，其语法如下： result = variable instanceof constructor 例子： alert(person instanceof Object); // 变量person是Object吗 alert(colors instanceof Array); // 变量colors是Array吗 alert(pattern instanceof RegExp); // 变量pattern是RegExp吗 所有引用类型的值都是Object的实例。因此检测一个引用类型的值和Object构造函数时，instanceof操作符始终返回true。instanceof检测基本数据类型的值，会返回false。因为基本类型不是对象。 4.2 执行环境及作用域 执行环境定义了变量和函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境。在Web浏览器中，全局环境被认为是window对象。因此，所有全局变量和函数都是window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出–例如关闭网页或浏览器–才会被销毁) 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制器返回之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含一个变量，即arguments对象(这个对象在全局环境中不存在)。作用域链的下一个变量来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 4.2.1 没有块级作用域 执行环境的类型总共有两种————全局和局部(函数)。Javascript没有块级作用域。 1. 声明变量 使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。123456function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //由于sum不是有效的变量，因此会导致错误 如果省略了var关键字，那么当add()执行完毕后，sum也将可以访问到：123456function add(num1, num2) &#123; sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //30 注： 建议在初始化变量之前，一定要先声明 2. 查询标识符 就是在标识符所在的执行环境开始搜索，如果存在搜索过程停止，如果局部环境没有找到该变量名，则继续沿作用域链向上搜索，搜索过程将一直追溯到全局环境的变量对象。如果全局环境中也没有找到这个标识符，则意味着该变量尚未声明。12345var color = "blue";function getColor() &#123; return color;&#125;alert (getColor()) //"blue" 局部环境不存在变量color,则会到全局环境中查找 如果局部环境中存在着标识符则123456var color = "blue";function getColor() &#123; var color = "red"; return color;&#125;alert(color) //"red" 此时会直接获取局部环境中的color值，全局环境中的color只能使用window.color访问。 4.3 垃圾收集 JavaScript具有自动垃圾收集机制，也就是说执行环境会负责管理代码执行过程中使用的内存。具体到浏览器中的实现，则有两个策略： 4.3.1 标记清除 JavaScript中最常用的垃圾收集方式是标记清除。当变量进入环境(例如：在函数中声明一个变量)时，这个变量标记为”进入环境”。可以用任何方式来标记变量。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为”离开环境”。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数 另一种不太常见的垃圾策略叫做引用计数。 引用类型 引用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称之为对象定义，因为它们描述的是一类对象所具有的属性和方法。 对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。下面代码： var person = new Object(); 这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数时Object,它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型(例如 Object)。 5.1 Object类型 目前为止，我们看到的大多数引用类型的值都是Object类型的实例；Object也是ECMAScript中使用最多的一个类型。 创建Object实例的两种方式。 1. 使用new操作符后跟Object构造函数 var person = new Object(); 2. 使用对象字面量表示法 var person = {}; 关于对象字面量用法，推荐只在考虑对象属性名可读性时使用。 实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：123456789101112131415161718192021function displayInfo(args) &#123; var output = ''; if (typeof args.name == "string") &#123; output += "Name: " + args.name + "\n"; &#125; if (typeof args.age == "number") &#123; output += "Age: " + args.age + "\n"; &#125; alert(output)&#125;displayInfo(&#123; name: 'Nichols', age: 29&#125;);displayInfo(&#123; name: 'Greg'&#125;);// 这种传递参数的模式最适合需要向函数传递大量可选参数的情形。 5.2 Array类型 ECMAScript数组的每一项可以保存任何类型的数据。也就是说可以用数组的第一个位置来保存字符串，用第二个位置来保存数值，用第三个位置来保存对象。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。 创建数组的基本方式有两种。 1. 使用Array构造函数 var colors = new Array(); 如果预先知道数组保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性。 如：var colors = new Array(20); 也可以向Array构造函数传递数组中应该包含的项。如： var colors = new Array(“red”, “blue”, “green”); 2. 使用数组字面量表示法。 var colors = [“red”, “blue”, “green”]; 数组length属性很有特点—它不是只读的。因此，可以通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。例：123var colors = ["red", "green", "blue"]; //创建一个包含3个字符串的数组colors.length = 2;alert(colors[2]) //undefined 通过设置length属性值为2，会移除最后一项 如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值123var colors = ["red", "blue", "green"];colors.length = 4;alert(colors[3]); //undefined 利用length属性也可方便的在数组末尾添加新项 5.2.1 检测数组 ECMAScript5新增Array.isArray()。这个方法的目的是最终确定某个值到底是不是数组，而不管在那个全局执行环境中创建。 用法如下： if (Array.isArray(value)){} 5.2.2 转换方法 如前所述，所有对象都具有toLocalString()、toString()和valueOf()方法12345var colors = ["red", "green", "blue"];alert(colors.toString()) //"red, green, blue"alert(colors.valueOf()) //["red", "green", "blue"]// toString()方法会返回由数组每个值的字符串拼接而成的一个以逗号分隔的字符串。而调用valueOf()返回的还是数组。 12345var colors = ["red", "green", "blue"];alert(colors.join(",")); //"red,green,blue" join方法重现了toString()方法的输出alert(colors.join("||")); //"red||green||blue"// 如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。 注： 如果数组中的某一项值是null或者undefined，那么该值在join()、toLocalString()、toString()、valueOf()方法返回的结果中以空字符串表示 5.2.3 栈方法 栈是一种LIFO(Last-In-First-Out,后进先出)的数据结构，也就是最新添加的项最早被移除。栈中项的插入(叫做推入)和移除(叫做弹出)，只发生在一个位置————栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。 1. push() push()方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度12345var colors = new Array();var count = colors.push("red", "green"); //推入两项alert(count); //2count = colors.push("black"); //推入另一项alert(count); //3 1. pop() pop()方法是从数组末尾移除最后一项，减少数组的length值并返回移除的项123var colors = new Array("red", "green", "black");var item = colors.pop();alert(item); //black 5.2.4 队列方法 队列结构的访问规则是FIFO(First-In-First-Out,先进先出)。队列在列表的末端添加项，从列表的前端移除项。 1 shift() 它能够移除数组中的第一项并返回该项，同时将数组长度减1。1234var colors = new Array("red", "green", "black");var item = colors.shift();alert(item); //redalert(colors.length); //2 2 unshift() ECMAScript还为数组提供了unshift()方法。unshift()和shift()的用途相反： 它在数组前端添加任意个项并返回数组的长度12345var colors = new Array();var count = colors.unshift("red", "green");alert(count); //2count = colors.unshift("black");alert(count); //3 5.2.5 重排序方法 数组中已经存在两个可以直接重排序的方法：reverse()和sort() 1. reverse()123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //[5,4,3,2,1] 2. sort() 默认情况下，sort()是按升序排列数组项。sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项是数值，sort()方法比较的也是字符串123var values = [0, 1, 5, 10, 15];values.sort();alert(values); [0, 1, 10, 15, 5]; //因为sort()方法是根据字符串比较大小，虽然数值5小于10，但进行字符串比较时，"10"则位于"5"的前面。 sort()方法可以接收一个比较函数作为参数，如果第一个参数应该位于第二个之前则返回负数，如果相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。例：12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 3, 5, 10, 15];values.sort(compare)alert(values); //[0, 1, 3, 5, 15] 5.2.6 操作方法 ECMAScript为操作已经包含在数组中的项提供了很多方法。 1. concat() concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会想创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"])alert(colors); //red,green,bluealert(colors2); //red,green,blue,black.brown 2. slice() 它能够基于当前数组中的一个或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。注意，slice()方法不会影响原始数组。123456var colors = ["red", "green", "blue", "black", "yellow"]var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,black,yellow 在只有一个参数的情况下，返回从该参数指定位置开始到当前数组末尾的所有项alert(colors3); ////green,blue,black 两个参数的情况下，返回起始和结束位置之间的项————但不包含结束位置项。 注： 如果slice()方法包含负数，则用数组长度加上该数来确定相应的位置。例如：在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组 3. splice() 删除：可以删除任意数量的项，需指定2个参数：要删除的第一项的位置和要删除的项数。例：splice(0,2)会删除数组的前两项。 插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0、要插入的项。例如：splice(2,0,”red”,”green”);会从当前数组的位置2开始插入字符串”red”和”green”。 替换：可以向指定位置插入任意数量的项，同时删除任意数量的项。需指定3个参数：起始位置、要删除的项数、要插入任意数量的项。插入的项数不必与删除的项数相等。例如：splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”123456789101112var colors = ["red","green","blue"];var removed = colors.splice(0,1); //删除第一项alert(colors); //green,bluealert(removed); //red,返回的数组中只包含一项removed = colors.splice(1,0,"yellow","orange"); //从位置1开始插入两项alert(colors); //green,yellow,orange,bluealert(removed); //[]返回一个空数组removed = colors.splice(1,1,"red","purple"); //插入两项，删除一项alert(colors); //green,red,purple,orange,bluealert(removed); //yellow 5.2.7 位置方法 indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和(可选的)表示查找起点位置的索引。这两个方法都返回要查找的项在数组中的位置，没有找到返回-1 5.2.8 迭代方法 1.every():对数组的每一项运行给定的函数，如果该函数对每一项都返回true,则返回true。12345var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2)&#125;)alert(everyResult); //false 2. some():对数组的每一项运行该函数，如果该数组对任何一项返回true,则返回true12345var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2)&#125;)alert(everyResult); //true 3.filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组12345var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var filterResult = numbers.filter(function(item, index, array)&#123; return item &gt; 2&#125;)alert(filterResult); //[3,4,5,4,3] 4.forEach():对数组的每一项运行给定函数，没有返回值。 5.map():对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。12345var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;)alert(mapResult); //[2, 4, 6, 8, 10, 8, 6, 4, 2] 5.2.9 归并方法 ECMAScript新增两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从第一项开始，逐项遍历到最后。reduceRight()从最后一项开始，向前逐项遍历。 方法都接收4个参数：前一个值、当前值、项的索引和数组对象。使用reduce()方法可以执行数组中所有值的和的操作：123456var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15//第一次执行回调函数prev是1，cur是2，第二次prev是3(1加2的结果)，cur是3(数组第三项)。会把数组中的每一项都访问一遍，最后返回结果。 5.3 Date类型 ECMAScript中的Date类型是使用1970年1月1日午夜(零时)开始经过毫秒数来保存的日期。 创建一个日期对象，使用new操作符和Date构造函数即可，如下：var now = new Date();要为2019年5月25日创建一个日期对象，可以使用：var someDate = new Date(Date.parse(“May 25, 2019”))；等价于var someDate = new Date(“May 25, 2019”); 5.4 RegExp类型 正则表达式：var expression = / pattern / flags ; 正则表达式的匹配模式支持下列3个标志： 1. g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； 2. i: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写； 3. m: 表示多行模式。即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。123var pattern1 = /at/g; //匹配字符串中所有"at"的实例var pattern2 = /[bc]at/i; //匹配第一个"bat"或"cat",不区分大小写var pattern3 = /.at/gi; //匹配所有以"at"结尾的3个字符的组合，不区分大小写 正则模式中使用的所有元字符都必须转义，正则表达式中的元字符包括： ( [ { \ ^ $ | ) ? * + . ] } 它们在正则表达式中都有一种或多种用途，因此，如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。例：1234var pattern1 = /[bc]at/i; //匹配第一个"bat"或"cat"，不区分大小写var pattern2 = /\[bc\]at/i; //匹配第一个"[bc]at"，不区分大小写var pattern3 = /.at/gi; //匹配所有以"at"结尾的3个字符的组合，不区分大小写var pattern4 = /\.at/gi; //匹配所有".at"，不区分大小写 5.4.1 RegExp实例属性 1. global: 布尔值，是否设置了g标志。 2. ignoreCase: 布尔值，表示是否设置了i标志。 3. lastIndex: 整数，表示开始搜索的下一个匹配项的字符位置，从0算起。 4. multiline: 布尔值，表示是否设置了m标志。 5. source: 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 例如：123456var pattern1 = /\[bc\]at/i;alert(pattern1.global); //falsealert(pattern1.ignoreCase); //truealert(pattern1.multiline); //falsealert(pattern1.lastIndex); //0alert(patten1.source); //"\[bc\]at" 5.4.2 RegExp实例方法 test()方法，它接受一个字符串参数。在模式与该参数匹配的情况下返回true;否则，返回false。例：12345var text = "000-00-0000"var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if (pattern.test(text)) &#123; alert("The pattern was matched")&#125; 5.5 Function类型 函数实际上是对象，每个函数都是Fuction类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是指向函数对象的指针，不会与某个函数绑定。函数通常使用函数声明语法定义。如下：123function (num1, num2) &#123; return num1 + num2&#125; 函数表达式定义函数：123var sum = function(num1, num2) &#123; return num1 + num2&#125; 最后定义函数的方式是使用Function构造函数12var sum = new Function("num1", "num2", "return num1 + num2") //不推荐//不过，这种语法对于理解"函数是对象，函数名是指针"的概念到时非常直观 由于函数名仅仅指向函数指针，因此函数名与包含对象指针的其他变量没有什么不同。12345678910function sum(num1, num2) &#123; return num1 + num2&#125;alert(sum(10,10)); //20var anotherSum = sum;alert(anotherSum(10,10)); //20sum = null;alert(anotherSum(10,10)); //20 5.5.1 没有重载 123456789101112131415161718192021function addSomeNumber(num)&#123; return num + 100;&#125;function addSomeNumber(num) &#123; return num + 200&#125;var result = addSomeNumber(100); //300//以上代码实际与下面代码没有什么区别var addSomeNumber = function (num) &#123; return num + 100;&#125;addSomeNumber = function (num) &#123; return num + 200&#125;var result = addSomeNumber(100); //300 5.5.2 函数声明与函数表达式 解析器在向执行环境加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在代码行，才会真正被解释执行。123456alert(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2&#125;//以上代码完全可以正常运行。代码执行前，解析器通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码数的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。 把函数声明改为等价的函数表达式，就会在执行期间导致错误。123456alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2&#125;//原因在于函数位于一个初始化语句中，而不是一个函数声明。在执行到函数所在语句之前，变量sum中不会保存对函数的引用；而且，第一行就会导致"unexpected identifier"(意外标识符)错误，实际上也不会执行到下一行。 注： 除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的 5.5.3 作为值的函数 因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。 function callSomeFunction(someFunction, someArgument){ return someFunction(someArgument) } 这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。例：1234567891011function add10(num)&#123; return num + 10;&#125;var result = callSomeFunction(add10, 10);alert(result1); //20function getGreeting(name)&#123; return "Hello, " + name;&#125;var result2 = callSomeFunction(getGreeting, "Nicholas");alert(result2); //"Hell0, Nicholas" 函数中返回另一个函数，是极为有用的一种技术。例：1234567891011121314151617181920function createComparisonFunction(properyName)&#123; return function(object1, object2) &#123; var value1 = object1[properyName]; var value2 = object2[properyName]; if (value1 &lt; value2) &#123; return -1 &#125; else if(value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125; &#125;&#125;var data = [&#123;name: 'Zachary', age: 28&#125;, &#123;name: 'Nicholas', age: 29&#125;];data.sort(createComparisonFunction("name"))alert(data[0].name); //Nicholasdata.sort(createComparisonFunction("age"))alert(data[0].name); //Zachary 5.5.4 函数内部属性 在函数内部有两个特殊对象：arguments和this。 1. arguments arguments是类数组对象，arguments主要用途是保存函数参数，这个对象还有一个属性名叫callee的属性，该属性是一个指针，指向用于arguments对象的函数12345678function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125;//定义的阶乘函数用到了递归算法，在函数名不变的情况下，这个定义没有问题。问题是这个函数执行与函数名factorial耦合在一起。 为解除紧密耦合的现象，可以使用arguments.callee。1234567function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1) &#125;&#125; 2. this this引用的是函数据以执行的环境对象———或者说是this的值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。例：12345678window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //"red"o.sayColor = sayColor;o.sayColor(); //"blue" 注： 函数的名仅仅是包含指针的变量。因此，即使在不同的环境中执行，全局的sayColor()和o.sayColor()指向的仍然是同一个函数。 5.5.5 函数属性和方法 ECMAScript中函数是对象。因此函数也有属性和方法。每个函数包含两个属性：length和prototype。 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法真正的存在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。 在ECMAScript中,prototype属性是不可枚举的，for-in无法发现。 每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用的函数，实际上等于设置函数体内this对象的值。 1. apply() apply()调用两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是Array的实例，也可以是arguments对象。例如：12345678910111213function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); //传入arguments对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]) //传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20//callSum1()在执行sum()函数时传入了this作为this值(因为是在全局作用域中调用，所以传入的就是window对象)和arguments对象。 2. call() call()方法与apply()方法的作用相同，区别在于接受参数的方式不同，第一个参数是this没有变，变化的是其余参数都是直接传递给函数。换言之，就是传递给函数的参数必须逐项列举。例：12345678function sun(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2)&#125;alert(callSum(10,10)); //20 事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方在于能够扩充函数赖以允许的作用域。例：1234567891011window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue //使用call()(或apply())来扩充作用域最大的好处，就是对象不需要与方法有任何耦合关系。 bind()ECMAScript还定义了一个方法：bind()。这个方法会创建一个函数的实例，this值会被绑定到传给bind()函数的值。例：123456789window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue//在这里，sayColor()调用bind()传入对象o,创建objectSayColor()函数。objectSayColor()函数的this值等于o，因此即使是在全局作用域中调用这个函数，也会看到"blue"。 5.6 基本包装类型 ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值时，后台会创建一个基本包装类型对象。例12345678910var s1 = "some text";var s2 = s1.substring(2);//我们知道,基本类型值不是对象，从逻辑上讲不应该有方法。但是，为了让我们实现直观这种操作，后台已经自动完成一系列处理://1. 创建String类型的实例//2. 在实例上调用方法//3. 销毁这个实例//可以将以上三个步骤想像成是执行了下列ECMAScript代码(同样适用于Boolean和Number类型对应的布尔值和数字值)var s1 = new String("some text");var s2 = s1.substring(2);s1 = null; 注： 自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。例：1234var s1 = "some text";s1.color = "red";alert(s1.color); //undefined//问题在于当第三行代码再次访问s1时，其color属性不见了。问题原因是第二行创建String对象在执行第三行代码时已经被销毁了。第三行代码又创建了自己的String对象，而该对象没有color属性。 5.6.1 String类型 String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。 1. 字符方法 两个用于访问字符串中特定字符的方法是:charAt()和charCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。 charAt()方法以单字符字符串的形式返回给定位置的字符。例如：12345var stringValue = "hello world";alert(stringValue.charAt(1)); //"e"//如果想得到的不是字符而是字符编码，就要像下面这样使用charCodeAt()var stringValue = "hello world";alert(stringValue.charCodeAt(1)); //输出"101",也就是小写字母e的字符编码 2. 字符串操作方法 concat()方法。用于将一或多个字符串拼接起来，返回拼接得到的新字符串。123456789var stringValue = "hello";var result = stringValue.concat("world");alert(result); //"hello world"alert(stringValue); //"hello"//concat()方法也可以接受任意多个参数，也可通过它拼接任意多个字符串。var stringValue = "hello";var result = stringValue.concat("world", "!");alert(result); //"hello world!"alert(stringValue); //"hello" slice()方法。会返回被操作字符串的一个子字符串，而且接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。123var stringValue = "hello world";alert(stringValue.slice(3)); //"lo world"alert(stringValue.slice(3, 7)); //"lo w"不包含最后一个 substr()方法。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)指定的是返回的字符个数。123var stringValue = "hello world";alert(stringValue.substr(3)); //"lo world"alert(stringValue.substr(3, 7)); //"lo worl" substring()方法。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。123var stringValue = "hello world";alert(stringValue.substring(3)); //"lo world"alert(stringValue.substring(3, 7)); //"lo w"不包含最后一个 3. 字符串位置方法 查找字符串方法：indexOf()和lastIndexOf()。都是从字符串中查找给定的子字符串，返子字符串的位置(没有找到该子字符串则返回-1)。区别在于indexOf()方法从字符串开头搜索，lastIndexOf()方法时从字符串末尾向前搜索子字符串。123var stringValue = "hello world";alert(stringValue.indexOf("o")); //4alert(stringValue.lastIndexOf("o")); //7 也可以接受第二个参数，表示从字符串那个位置开始搜索。123var stringValue = "hello world";alert(stringValue.indexOf("o", 6)); //7alert(stringValue.lastIndexOf("o", 6)); //4 可以通过循环找到所有匹配的字符串，如下：12345678910var stringValue = "Lorem ipsum dolor sit amet, consectertur adipisicing elit";var positions = new Array();var pos = stringValue.indexOf("e");if (pos &gt; -1) &#123; position.push(pos); pos = stringValue.indexOf("e", pos + 1)&#125;alert(positions); //"3, 24, 32, 35, 52" 4. trim()方法 方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。 5. 字符串大小写转换方法 toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase();例：12345var stringValue = "hello world";alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"alert(stringValue.toUpperCase()); //"HELLO WORLD"alert(stringValue.toLowerCase()); //"hello world"alert(stringValue.toLocaleLowerCase()); //"hello world" 6. 字符串的模式匹配方法 1 match()只接受一个参数，要么是一个正则表达式，要么是一个regExp对象。例：12345var text = "cat, bat, sat, fat";var pattern = /.at/;var matches = text.match(pattern);alert(matches.index); //0 2 search()方法。参数同match()方法，search()方法返回字符串中第一个匹配项索引；如果没有找到则返回-1 3 replace()方法。 replace()方法接受两个参数：第一个参数可以是regExp或者字符串，第二个可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一办法就是提供一个正则表达式，而且要指定全局(g)。例：123456var text = "cat, bat, sat, fat";var result = text.replace("at", ond);alert(result); //"cond, bat, sat, fat"result = text.replace(/at/g, "ond");alert(result); //"cond, bond, sond, fond" 5.7 单体内置对象 内置对象定义：”由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思是说，不必显式的实例化内置对象，因为它们已经实例化了。前面已经介绍了大多数内置对象，例如：Object、Array和String。ECMAScript还定义了两个单体内置对象：Global和Math。 5.7.1 Global对象 Global(全局)对象可以说是ECMAScript中最特别的对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的”兜底儿对象”来定义的。也就是说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如isNaN()、isFinite()、parseInt()及parseFloat(),实际上全是Global对象的方法。除此之外，还包含一些其他方法。 1. URI编码方法 Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器。有效的URI中不包含某个字符，例如空格。这两个URI编码方法可以对URI进行编码，它们用特殊的UTF-8编码替换无效的字符，从而让浏览器能够接受和理解。 encodeURI(): 主要用于整个URI(例如, http://www.wrox.com/illegal value.htm),而encodeURIComponent()主要用于对URI中的某一段(例如前面URI中的illegal value.html)进行编码。它们主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。123456var uri = "http://www.wrox.com/illegal value.htm#start";//"http://www.wrox.com/illegal%20value.htm#start"alert(encodeURI(uri));//"http%3A%2Fwww.wrox.com%2Fillegal%20value.htm%23start" alert(encodeURIComponent(uri)); 与encodeURI()和encodeURIComponent()对应的decodeURI()和decodeURIComponent()。其中decodeURI()只对使用encodeURI()替换的字符进行解码。例如。它将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号(#),而井字号不是使用encodeURI()替换的。同样，decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符。例：1234567//"http%3A%2Fwww.wrox.com%2Fillegal%20value.htm%23start"//"http%3A%2Fwww.wrox.com%2Fillegal value.htm%23start"alert(decodeURI(uri));//"http://www.wrox.com/illegal value.htm#start" alert(decodeURIComponent(uri)); 5.7.2 Math对象 1. min()和max()方法 min()和max()方法用于确定一组数值中的最小值和最大值。例：123456789var max = Math.max(3, 54, 32, 16);alert(max); //54var min = Math.min(3, 54, 32, 16);alert(min); //3//要找到数组中的最大值或最小值，可以使用apply()方法var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values) 2. 舍入方法 Math.ceil()执行向上舍入，即它总是将数值向上舍入为最近的整数。 Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数。 Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。1234567891011alert(Math.ceil(25.9)); //26alert(Math.ceil(25.5)); //26alert(Math.ceil(25.1)); //26alert(Math.round(25.9)); //26alert(Math.round(25.5)); //26alert(Math.round(25.1)); //25alert(Math.floor(25.9)); //25alert(Math.floor(25.5)); //25alert(Math.floor(25.1)); //25 2. random()方法 Math.random()方法返回大于等于0小于1的一个随机数。套用下面公式，可以利用Math.random()从某个整数范围内随机选择一个值。 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>summarize</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-summarize]]></title>
    <url>%2F2018%2F12%2F13%2Fcss-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文目的在于记录平时用到的一些常用CSS样式，常见的问题，用于以后自己方便使用，备忘。同时也希望对停留在这里的人，提供一些帮助！如何消除inline-block产生的元素间空隙 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 1.children &#123;display: inline-block;background: #ccc&#125; 运行结果： 空隙产生原因：HTML中的换行符、空格符、制表符等空白符，字体大小不为0的情况下，空白符占据一定宽度，使用inline-block会产生元素间的空隙 解决办法： 1. 父元素设置font-size设置为0，子元素的font-size设置为实际大小 2. 子元素设置浮动 3. 把所有子元素写在一行 4. 有时候子元素内容较长，所有子元素写在一行导致代码的可读性很差，这时候采用下面的写法（用HTML注释符把子元素连接起来）： 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 图片和文字水平对齐实现 1234&lt;div class=&quot;wrapper&quot;&gt; &lt;p class=&quot;text&quot;&gt;文字&lt;/p&gt; &lt;img src=&quot;imgUrl&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;&lt;/div&gt; 1234.text, .img &#123; display: inline-block; vertical-align: top;&#125; 多行文字垂直居中 1234// 元素高度不固定&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;children&quot;&gt;桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖&lt;/p&gt;&lt;/div&gt; 12345678// vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table.parent &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle;&#125; div实现水平垂直居中 123&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122// 1.container &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125;// 2.container &#123; display: flex; justify-content: center; align-items: center; height: 100%;&#125;.box &#123; width: 100px; height: 100px; background-color: red;&#125; flex实现左侧宽度固定，右侧宽度自适应 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left-part&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right-part&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567.left-part &#123; flex: 0 0 88px; width: 88px;&#125;.right-part &#123; flex: 1&#125; css-sticky-footer布局 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;warpper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;icon-footer&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.container &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(7, 17, 27, 0.8);&#125;.wrapper &#123; width: 100%; min-height: 100%;&#125;.content &#123; padding: 64px 0;&#125;.icon-footer &#123; margin: -64px auto 0;&#125; CSS3 transitions to the z-index 123456&lt;!-- Hover over the first div, labeled One, for at least three seconds to see how it transitions from a z-index value of 1 (the bottom of the stack) to a z-index value of 6 (top of the stack) --&gt; &lt;div class=&quot;one&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;three&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;four&lt;/div&gt; &lt;div class=&quot;five&quot;&gt;five&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546div &#123; position: absolute; height: 200px; width: 200px;&#125;.one &#123; z-index: 1; top: 0; left: 0; width: 800px; background: hsla(1, 70%, 50%, .5); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.one:hover &#123; z-index: 6; background: hsla(1,100%,10%,1); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.two &#123; z-index: 2; top: 120px; left: 0; background: hsla(50, 70%, 50%, .5);&#125;.three &#123; z-index: 3; top: 120px; left: 160px; background: hsla(120, 70%, 50%, .5);&#125;.four &#123; z-index: 4; top: 120px; left: 320px; background: hsla(220, 70%, 50%, .5);&#125;.five &#123; z-index: 5; top: 120px; left: 480px; background: hsla(300, 70%, 50%, .5);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>summarize</tag>
      </tags>
  </entry>
</search>
