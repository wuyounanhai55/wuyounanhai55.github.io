<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js-summarize]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文是基于JavaScript高级程序设计内容的一个总结，算作读书笔记？或者是备忘，也算是一种总结，希望能掌握一些基础的知识，更有利于以后的学习开发。与君共勉！Javascript诞生于1995年, 当时就职于Netscape 公司的布兰登·艾奇,计划于1995年2月发布由Netscape Navigator 2开发的脚本语音LiveScript,为了赶在发布日期之前，Netscape与Sun公司建立了一个开发联盟。在Netscape Navigator 发布前夕，Netscape为了搭载上热炒Java的顺风车，临时把LiveScript 改为 JavaScript。 Javascript 是一种专为与网页交互而设计的脚本语言，由以下三部分组成: ECMAScript，由ECMA-262定义，提供核心语言功能 文档对象模型（DOM）,提供访问和操作网页内容的方法和接口 浏览器对象模型（BOM）,提供与浏览器接口交互的方法和接口 在HTML中使用JavaScript &lt;script&gt;元素 &lt;script&gt;定义了6个属性 async: 可选 表示应该立即下载脚本，但不妨碍页面其他操作，只对外部脚本文件有效，不能保证异步脚本按照它们在页面的顺序执行 charset: 可选。 defer: 可选。表示脚本可以延迟到文档被完全解析后再执行。只对外部脚本文件有效，最好只包含一个延迟脚本，延迟脚本总是按照指定它们的顺序执行 language: 已废弃 src: 表示要引用的外部文件 type: 可选。表示编写代码使用的脚本语言的内容类型 &lt;noscript&gt;元素 在&lt;noscript中的内容在下面两种情况下才显示出来 浏览器不支持脚本 浏览器支持脚本，但被禁用 JavaScript将被从上到下依次执行,在所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载显示，在不使用defer和async的情况下 基本概念 1. 语法 1.1 区分大小写 ECMAScript中的一切(变量、函数名和操作符)都区分大小写 1.2 标识符 标识符 就是指变量、函数、属性或者函数参数。标识符规则如下 1 第一个字符必须是字母、下划线 或 $ 2 其他字符可以是字母、数字、下划线 或 $ 按照惯例，ECMAScript采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写，如：firstSecond myCar 1.3 注释 // 单行注释 /* 这是一行多行注释 */ 1.4 严格模式 ECMAScript5引入严格模式，严格模式是为JavaScript定义了一种不同的解析与执行模型。要在整个模式启用严格模式，可以在顶部添加如下代码： “use strict” 1.5 语句 ECMAScript中的语句以一个分号结尾；虽然语句的分号不是必需的，但建议任何时候都不要省略它。 2. 数据类型 ECMAScript中有五种基本操作类型: Number、String、Bollean、Null、Undefined，还有一种复杂的数据类型Object。ECMAScript不支持任何创建自定义类型的机制，所有值最终将是上述6中类型之一。 2.1 typeof操作符 使用typeof检测数据类型，使用typeof操作符返回下列某个字符串： 1. “undefined”: 如果这个值未定义； 2. “bollean”: 如果这个值是布尔值； 3. “string”: 如果这个值是字符串； 4. “number”: 如果这个值是数字； 5. “object”: 如果这个值是对象或者null； 6. “function”: 如果这个值是函数 2.2 Undefined类型 在使用var声明变量但未对其初始化时,这个变量的值就是undefined,例如:12var message; //只定义了变量，未初始化变量alert(message === undefined) //true 注： 未声明的变量执行typeof也会返回undefined,初始化声明的变量是明智的选择。 2.3 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊值是null。从逻辑角度看，null表示一个空对象指针，而这也正是使用typeof操作符检测null值时返回”object”的原因。 实际上，undefined值是派生自null值的，因此ECMA-262规定对他们的相等性检测返回true1alert(null == undefined) // true 2.4 Bollean类型 该类型只有两个字面值：true和false 2.5 Number类型 这种类型使用IEEE754格式来表示整数和浮点数组。 最基本的数值字面量格式是十进制整数。如 var intNum = 55; //整数 除十进制表示外，整数还有八进制和十六进制，其中八进制第一位必须是零，然后八进制数字序列(0~7),如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值当作十进制数值解析。123 var octalNum1 = 070; //八进制的56 var octalNum2 = 079; //无效的八进制数值,解析为79 var octalNum3 = 08; //无效的八进制数值，解析为8 注： 八进制字面量在严格模式下是无效的。 十六进制字面量的前两位必须是0x,后跟任何十六进制数字(0~9及A~F)。其中可以大写，也可以小写。12var hexNum1 = 0xA; //十六进制的10var hexNum2 = 0x1f; //十六进制的31 2.5.1 数值范围 ECMAScript 能够保存的最小值保存在 Number.MIN_VALUE中，在大多数浏览器中这个数是5e-324。超过这个数值，则会被转换为-Infinity(负无穷)；最大值保存在Number.MAX_VALUE中，在大多数浏览器中这个数是1.7976931348623157e+308。超过这个数值，则会被转换为Infinity(正无穷) 2.5.2 NaN NaN，非数值(Not a Number) 是一个特殊的数值，这个数值表示一个本来要返回数值的操作数未返回数值的情况(这样就不抛出错误了)。例如: 任何数值除以0都会导致错误，但在ECMAScript中，任何数值除以0会返回NaN,不影响代码执行。 NaN两个特点: 1. 任何涉及NaN的操作(例如：NaN/10)都会返回NaN,在多步计算中可能导致问题。2. NaN与任何值都不相等，包括NaN本身。 ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型的数据，而函数会帮我们确定该参数是否”不是数值”12345isNaN(NaN) //trueisNaN(10) //false (10是一个数值)isNaN(&quot;10&quot;) //false (可以被转换成数值10)isNaN(&quot;blue&quot;) //true (不能转换成数值)isNaN(&quot;true&quot;) //false (可以被转换成数值1) 注: 实际上只有0除以0才会返回NaN，正数除以0返回Infinity,负数除以0返回-Infinity 2.5.3 数值转换 Number()、parseInt()、parseFloat()可以把非数值转换为数值。其中Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有不同的返回结果。 Number()函数转换规则如下。 1. 如果是Boolean值，true和false将分别被转换为1和0 2. 数字值，只是简单的传入和返回。 3. null值，返回0。 4. undefined，返回NaN。 5. 如果是字符串，遵循下列规则: 1 如果字符串只包含数字，则将其转换为十进制数值 2 如果包含有效的浮点格式数据，则将其转换为对应的浮点数值。 3 如果包含有效的十六进制数据，则将其转换为相同大小的十进制整数值。 4 如果字符串为空，则将其转换为0。 5 如果字符串包含除上述以外的字符，则将其转换为NaN。 6. 如果是对象，则调用对象的valueOf()方法，然后按照前面规则转换返回的值。如果转换结果为NaN,则调用对象的toString()方法，然后再按照前面的规则转换返回的字符串值。1234Number(&apos;hello world&apos;) // NaNNumber(&quot; &quot;) // 0Number(&quot;00011&quot;) // 11Number(true) // 1 处理整数的时候更常用的是parseInt()函数。parseInt(string)函数规则如下： 1. 字符串第一个不是数字字符或者负号，parseInt()返回NaN,也就是说parseInt()转换空字符串也会返回NaN。 2. 如果第一个字符是字符串，则直到解析完后续的字符或者遇到了一个非数字字符。例如，”1234blue”会被转会为1234，类似的”22.5”会被转换为22，因为小数点并不是有效的数字字符。 3. 同样的parseInt()也能识别各种整数格式(即十进制、八进制、十六进制)，如果字符串以”0x”开头且后跟数字字符，就会将其当作十六进制整数；如果字符串以”0”开头且后跟数字字符，则会当作八进制数来解析。1234567parseInt(&quot;1234blue&quot;); //1234parseInt(&quot;&quot;); //NaNparseInt(&quot;0xA&quot;); //10parseInt(&quot;22.5&quot;); //22parseInt(&quot;070&quot;); //56parseInt(&quot;70&quot;); //70parseInt(&quot;0xf&quot;); //15 可以为函数提供第二个参数:转换时使用的基数(即多少进制)，例如：123parseInt(&quot;0xAF&quot;, 16); //175parseInt(&quot;AF&quot;, 16); //175parseInt(&quot;AF&quot;); //NaN 指定基数会影响到转换的输出结果。例如：1234parseInt(&quot;10&quot;, 2) //2 (按二进制解析)parseInt(&quot;10&quot;, 8) //8 (按八进制解析)parseInt(&quot;10&quot;, 10) //10 (按十进制解析)parseInt(&quot;10&quot;, 16) //16 (按十六进制解析) parseFloat(string)函数规则: 1. 与parseInt()函数类似，直到解析遇到无效的浮点数字字符为止。字符串中的第一个小数点是有效的，第二个小数点是无效的。例，”22.34.5”将会被转换为22.34 2. parseFloat()会忽略前导零。十六进制的字符串始终会被转换为0。parseFloat()只解析十进制数值。因此没有用第二个参数指定基数的用法。123456parseFloat(&quot;1234blue&quot;); //1234parseFloat(&quot;0xA&quot;); //0parseFloat(&quot;22.5&quot;); //22.5parseFloat(&quot;22.34.5&quot;); //22.34parseFloat(&quot;0908.5&quot;); //908.5parseFloat(&quot;3.125e7&quot;); //31250000 2.6 String类型 String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。 2.6.1 转换为字符串 方法一：toString()1234var age = 11;age.toString(); //字符串&quot;11&quot;var found = true;found.toString(); //字符串&quot;true&quot; 数值、布尔值、对象和字符串值都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是调用数值的toString()的方法时，可以传递一个参数：输出数值的基数。123456var num = 10;num.toString(); //&quot;10&quot;num.toString(&quot;2&quot;); //&quot;1010&quot;num.toString(&quot;10&quot;); //&quot;10&quot;num.toString(&quot;8&quot;); //&quot;12&quot;num.toString(&quot;16&quot;); //&quot;a&quot; 注： 默认(没有参数的)输出值与指定基数10时的输出值相同 方法二：string() 在不知道数值数是不是null或undefined的情况下，可以使用转型函数string();这个函数能够将任何类型的值转换为字符串。转换规则如下： 1 如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果。 2 如果值是null,则返回”null”。 3 如果值是undefined，则返回”undefined”123456789var value1 = 10;var value2 = true;var value3 = null;var value4;String(value1); //&quot;10&quot;String(value2); //&quot;true&quot;String(value3); //&quot;null&quot;String(value4); //&quot;undefined&quot; 2.7 Object类型 ECMAScript中的对象就是一组数据和功能的集合。对象可以执行new操作符后跟要创建的对象类型的名称来创建。如: var o = new Object(); Object类型是所有它的实例的基础。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object每个实例都具有下列属性和方法： 1 constructor: 保存着用于创建当前对象的函数。对前面例子而言，构造函数(constructor)就是Object(); 2 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中(而不是在对象原型中存在)是否存在。作为参数的属性名(propertyName)必须以字符串的形式指定。(例如：o.hasOwnProperty(“name”)) 3 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型。 4 propertyIsEnumerable(propertyName): 用于检查给定的属性是否能用for-in语句来枚举。作为参数的函数名必须以字符串形式指定。 5 toLocalString(): 返回对象的字符串表示，该字符传与执行环境的地区对应。 6 toString(): 返回对象的字符串表示。 7 valueOf(): 返回对象的字符串、布尔值或数值表示。 3. 语句 3.1 if 语句 3.2 do-while 语句 在对条件表达式求值之前，循环体内的代码最少会被执行一次。1234var i = 0;do &#123; i += 2;&#125; while(i &lt; 10) 3.3 while 语句 while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。1234var i = 0;while ( i &lt; 10) &#123; i += 2;&#125; 3.4 for 语句 3.5 for-in 语句 for-in语句是一种精准的迭代语句，用来枚举对象的属性。for-in语句的语法： for(property in expression) statement123for (var propName in window) &#123; document.write(propName)&#125; 3.5 switch 语句123456789switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; ECMAScript中的switch语句，可以在switch中使用任何类型的数据，其次case不一定是常量，可以是变量，甚至是表达式。例12345678910switch(&apos;hello world&apos;) &#123; case: &quot;hello&quot; + &quot;world&quot;: alert(&quot;Greeting was found&quot;); break; case: &quot;goodbye&quot;: alert(&quot;Closing was found&quot;); break; default: alert(&quot;Unexpected message was found&quot;);&#125; 3.6 函数 ECMAScript中使用function关键字来声明,后跟一组参数以及函数体。 function functionName(arg0, arg1,…,argN) { statements } ECMAScript 中的函数在定义时不必指定是否返回返回值。函数执行完return语句后停止并立即退出。return语句可以不带任何返回值，这种情况下，函数停止执行后返回undefined。 3.6.1 理解参数 ECMAScript函数对参数数量和数据类型无限制，原因是ECMAScript中的参数在内部用一个数组来表示。实际上，在函数体内通过arguments对象来访问这个数组。使用length属性来确定传递进来多少个参数。(arguments对象只是与数组类似，并不是Array的实例)。arguments对象可以与命名参数一起使用。如：1234567function (num1, num2) &#123; if (arguments.length == 1) &#123; alert(num1 + 10) &#125; else if (arguments.length == 2) &#123; alert(arguments[0] + num2) &#125;&#125; arguments的值永远与对应命名参数的值保持同步。arguments对象的长度由传入参数的个数决定，不是由定义函数时的命名参数的个数决定的。 注： 没有传递值的命名参数将自动被赋予undefined值。这就跟定义了没有初始化一样。 3.7 没有重载 ECMAScript函数不能像传统意义上那样实现重载。如果定义了两个名字相同的函数，则该名字只属于后定义的函数。例：123456789function addsomeNumber(num) &#123; return num + 100&#125;function addsomeNumber(num) &#123; return num + 200&#125;var result = addsomeNumber(100) 返回结果是300，后定义的会覆盖先定义的函数。 变量、作用域、内存问题ECMAScript变量包含基本类型值和引用类型值，基本类型的值是按值访问的，因此可以操作保存表里中的实际值，引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 注： 当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际对象 4.1.1 动态的属性 对于引用类型的值，我们可以为其添加属性和方法，也可以删除和改变其属性和方法。123var person = new Object();person.age = 18;alert(person.age); //18 不能给基本类型值添加属性，只能给引用类型值添加属性。 4.1.2 复制变量值 基本数据类型值的变量的复制会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。这两个变量可以参与任何操作而不会相互影响。 变量复制引用类型的值时，也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针。而这个指针指向存储在堆中的一个对象。两个变量实际上引用的是同一个对象。改变其中一个变量，也会影响另一个变量。例：1234var obj1 = new Object();var obj2 = obj1;obj1.name = &quot;Nicholas&quot;alert(obj2.name) //Nicholas 4.1.3 传递参数 ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 在向参数传递基本数值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量会反映在函数的外部。12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);alert(count); //20,没有变化alert(result); //30 如果使用对象，再举一个例子：1234567function setName(obj) &#123; obj.name = &apos;jim&apos;&#125;var person = new Object();setName(person);alert(person.name) //&quot;jim&quot; 为了证明对象是按值传递的，再看一下经过修改的例子：12345678function setName(obj) &#123; obj.name = &quot;jim&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();setName(person);alert(person.name); //&quot;jim&quot; 如果person是按引用传递的，那么person就会自动修改为指向其name属性值为”Greg”的新对象。但是实际是没有变，仍为”jim”。实际上，当函数内部重写obj时，这个变量引用的就是一个局部对象了。这个局部对象会在函数执行完毕后立即被销毁。 4.1.4 检测类型 检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，用处不大。 ECMAScript提供了instanceof操作符，其语法如下： result = variable instanceof constructor 例子： alert(person instanceof Object); // 变量person是Object吗 alert(colors instanceof Array); // 变量colors是Array吗 alert(pattern instanceof RegExp); // 变量pattern是RegExp吗 所有引用类型的值都是Object的实例。因此检测一个引用类型的值和Object构造函数时，instanceof操作符始终返回true。instanceof检测基本数据类型的值，会返回false。因为基本类型不是对象。 4.2 执行环境及作用域 执行环境定义了变量和函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境。在Web浏览器中，全局环境被认为是window对象。因此，所有全局变量和函数都是window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出–例如关闭网页或浏览器–才会被销毁) 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制器返回之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含一个变量，即arguments对象(这个对象在全局环境中不存在)。作用域链的下一个变量来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 4.2.1 没有块级作用域 执行环境的类型总共有两种————全局和局部(函数)。Javascript没有块级作用域。 1. 声明变量 使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。123456function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //由于sum不是有效的变量，因此会导致错误 如果省略了var关键字，那么当add()执行完毕后，sum也将可以访问到：123456function add(num1, num2) &#123; sum = num1 + num2; return sum;&#125;var result = add(10, 20); //30alert(sum); //30 注： 建议在初始化变量之前，一定要先声明 2. 查询标识符 就是在标识符所在的执行环境开始搜索，如果存在搜索过程停止，如果局部环境没有找到该变量名，则继续沿作用域链向上搜索，搜索过程将一直追溯到全局环境的变量对象。如果全局环境中也没有找到这个标识符，则意味着该变量尚未声明。12345var color = &quot;blue&quot;;function getColor() &#123; return color;&#125;alert (getColor()) //&quot;blue&quot; 局部环境不存在变量color,则会到全局环境中查找 如果局部环境中存在着标识符则123456var color = &quot;blue&quot;;function getColor() &#123; var color = &quot;red&quot;; return color;&#125;alert(color) //&quot;red&quot; 此时会直接获取局部环境中的color值，全局环境中的color只能使用window.color访问。 4.3 垃圾收集 JavaScript具有自动垃圾收集机制，也就是说执行环境会负责管理代码执行过程中使用的内存。具体到浏览器中的实现，则有两个策略： 4.3.1 标记清除 JavaScript中最常用的垃圾收集方式是标记清除。当变量进入环境(例如：在函数中声明一个变量)时，这个变量标记为”进入环境”。可以用任何方式来标记变量。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为”离开环境”。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被变量中的变量引用的变量的标记。而在此之后再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数 另一种不太常见的垃圾策略叫做引用计数。 引用类型 引用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称之为对象定义，因为它们描述的是一类对象所具有的属性和方法。 对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。下面代码： var person = new Object(); 这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数时Object,它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型(例如 Object)。 5.1 Object类型 目前为止，我们看到的大多数引用类型的值都是Object类型的实例；Object也是ECMAScript中使用最多的一个类型。 创建Object实例的两种方式。 1. 使用new操作符后跟Object构造函数 var person = new Object(); 2. 使用对象字面量表示法 var person = {}; 关于对象字面量用法，推荐只在考虑对象属性名可读性是使用。 实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：123456789101112131415161718192021function displayInfo(args) &#123; var output = &apos;&apos;; if (typeof args.name == &quot;string&quot;) &#123; output += &quot;Name: &quot; + args.name + &quot;\n&quot;; &#125; if (typeof args.age == &quot;number&quot;) &#123; output += &quot;Age: &quot; + args.age + &quot;\n&quot;; &#125; alert(output)&#125;displayInfo(&#123; name: &apos;Nichols&apos;, age: 29&#125;);displayInfo(&#123; name: &apos;Greg&apos;&#125;);// 这种传递参数的模式最适合需要向函数传递大量可选参数的情形。 5.2 Array类型 ECMAScript数组的每一项可以保存任何类型的数据。也就是说可以用数组的第一个位置来保存字符串，用第二个位置来保存数值，用第三个位置来保存对象。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。 创建数组的基本方式有两种。 1. 使用Array构造函数 var colors = new Array(); 如果预先知道数组保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性。 如：var colors = new Array(20); 也可以向Array构造函数传递数组中应该包含的项。如： var colors = new Array(“red”, “blue”, “green”); 2. 使用数组字面量表示法。 var colors = [“red”, “blue”, “green”]; 数组length属性很有特点————它不是只读的。因此，可以通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。例：123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; //创建一个包含3个字符串的数组colors.length = 2;alert(colors[2]) //undefined 通过设置length属性值为2，会移除最后一项 如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];colors.length = 4;alert(colors[3]); //undefined 利用length属性也可方便的在数组末尾添加新项 5.2.1 检测数组 ECMAScript5新增Array.isArray()。这个方法的目的是最终确定某个值到底是不是数组，而不管在那个全局执行环境中创建。 用法如下： if (Array.isArray(value)){} 5.2.2 转换方法 如前所述，所有对象都具有toLocalString()、toString()和valueOf()方法12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.toString()) //&quot;red, green, blue&quot;alert(colors.valueOf()) //[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]toString()方法会返回由数组每个值的字符串拼接而成的一个以逗号分隔的字符串。而调用valueOf()返回的还是数组。 12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.join(&quot;,&quot;)); //&quot;red,green,blue&quot; join方法重现了toString()方法的输出alert(colors.join(&quot;||&quot;)); //&quot;red||green||blue&quot;// 如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。 注： 如果数组中的某一项值是null或者undefined，那么该值在join()、toLocalString()、toString()、valueOf()方法返回的结果中以空字符串表示 5.2.3 栈方法 栈是一种LIFO(Last-In-First-Out,后进先出)的数据结构，也就是最新添加的项最早被移除。栈中项的插入(叫做推入)和移除(叫做弹出)，只发生在一个位置————栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。 1. push() push()方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度12345var colors = new Array();var count = colors.push(&quot;red&quot;, &quot;green&quot;); //推入两项alert(count); //2count = colors.push(&quot;black&quot;); //推入另一项alert(count); //3 1. pop() pop()方法是从数组末尾移除最后一项，减少数组的length值并返回移除的项123var colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;black&quot;);var item = colors.pop();alert(item); //black 5.2.4 队列方法 队列结构的访问规则是FIFO(First-In-First-Out,先进先出)。队列在列表的末端添加项，从列表的前端移除项。 1 shift() 它能够移除数组中的第一项并返回该项，同时将数组长度减1。1234var colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;black&quot;);var item = colors.shift();alert(item); //redalert(colors.length); //2 2 unshift() ECMAScript还为数组提供了unshift()方法。unshift()和shift()的用途相反： 它在数组前端添加任意个项并返回数组的长度12345var colors = new Array();var count = colors.unshift(&quot;red&quot;, &quot;green&quot;);alert(count); //2count = colors.unshift(&quot;black&quot;);alert(count); //3 5.2.5 重排序方法 数组中已经存在两个可以直接重排序的方法：reverse()和sort() 1. reverse()123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //[5,4,3,2,1] 2. sort() 默认情况下，sort()是按升序排列数组项。sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项是数值，sort()方法比较的也是字符串123var values = [0, 1, 5, 10, 15];values.sort();alert(values); [0, 1, 10, 15, 5]; //因为sort()方法是根据字符串比较大小，虽然数值5小于10，但进行字符串比较时，&quot;10&quot;则位于&quot;5&quot;的前面。 sort()方法可以接收一个比较函数作为参数，如果第一个参数应该位于第二个之前则返回负数，如果相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。例：12345678910111213function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0, 1, 3, 5, 10, 15];values.sort(compare)alert(values); //[0, 1, 3, 5, 15] 5.2.6 操作方法 ECMAScript为操作已经包含在数组中的项提供了很多方法。 1. concat() concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会想创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;])alert(colors); //red,green,bluealert(colors2); //red,green,blue,black.brown 2. slice() 它能够基于当前数组中的一个或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。注意，slice()方法不会影响原始数组。123456var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;, &quot;yellow&quot;]var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,black,yellow 在只有一个参数的情况下，返回从该参数指定位置开始到当前数组末尾的所有项alert(colors3); ////green,blue,black 两个参数的情况下，返回起始和结束位置之间的项————但不包含结束位置项。 注： 如果slice()方法包含负数，则用数组长度加上该数来确定相应的位置。例如：在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组 3. splice() 删除：可以删除任意数量的项，需指定2个参数：要删除的第一项的位置和要删除的项数。例：splice(0,2)会删除数组的前两项。 插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0、要插入的项。例如：splice(2,0,”red”,”green”);会从当前数组的位置2开始插入字符串”red”和”green”。 替换：可以向指定位置插入任意数量的项，同时删除任意数量的项。需指定3个参数：起始位置、要删除的项数、要插入任意数量的项。插入的项数不必与删除的项数相等。例如：splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”123456789101112var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];var removed = colors.splice(0,1); //删除第一项alert(colors); //green,bluealert(removed); //red,返回的数组中只包含一项removed = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;); //从位置1开始插入两项alert(colors); //green,yellow,orange,bluealert(removed); //[]返回一个空数组removed = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;); //插入两项，删除一项alert(colors); //green,red,purple,orange,bluealert(removed); //yellow]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>summarize</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-summarize]]></title>
    <url>%2F2018%2F12%2F13%2Fcss-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文目的在于记录平时用到的一些常用CSS样式，常见的问题，用于以后自己方便使用，备忘。同时也希望对停留在这里的人，提供一些帮助！如何消除inline-block产生的元素间空隙 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 1.children &#123;display: inline-block;background: #ccc&#125; 运行结果： 空隙产生原因：HTML中的换行符、空格符、制表符等空白符，字体大小不为0的情况下，空白符占据一定宽度，使用inline-block会产生元素间的空隙 解决办法： 1. 父元素设置font-size设置为0，子元素的font-size设置为实际大小 2. 子元素设置浮动 3. 把所有子元素写在一行 4. 有时候子元素内容较长，所有子元素写在一行导致代码的可读性很差，这时候采用下面的写法（用HTML注释符把子元素连接起来）： 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 图片和文字水平对齐实现 1234&lt;div class=&quot;wrapper&quot;&gt; &lt;p class=&quot;text&quot;&gt;文字&lt;/p&gt; &lt;img src=&quot;imgUrl&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;&lt;/div&gt; 1234.text, .img &#123; display: inline-block; vertical-align: top;&#125; 多行文字垂直居中 1234// 元素高度不固定&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;children&quot;&gt;桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖&lt;/p&gt;&lt;/div&gt; 12345678// vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table.parent &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle;&#125; div实现水平垂直居中 123&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122// 1.container &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125;// 2.container &#123; display: flex; justify-content: center; align-items: center; height: 100%;&#125;.box &#123; width: 100px; height: 100px; background-color: red;&#125; flex实现左侧宽度固定，右侧宽度自适应 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left-part&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right-part&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567.left-part &#123; flex: 0 0 88px; width: 88px;&#125;.right-part &#123; flex: 1&#125; css-sticky-footer布局 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;warpper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;icon-footer&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.container &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(7, 17, 27, 0.8);&#125;.wrapper &#123; width: 100%; min-height: 100%;&#125;.content &#123; padding: 64px 0;&#125;.icon-footer &#123; margin: -64px auto 0;&#125; CSS3 transitions to the z-index 123456&lt;!-- Hover over the first div, labeled One, for at least three seconds to see how it transitions from a z-index value of 1 (the bottom of the stack) to a z-index value of 6 (top of the stack) --&gt; &lt;div class=&quot;one&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;three&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;four&lt;/div&gt; &lt;div class=&quot;five&quot;&gt;five&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546div &#123; position: absolute; height: 200px; width: 200px;&#125;.one &#123; z-index: 1; top: 0; left: 0; width: 800px; background: hsla(1, 70%, 50%, .5); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.one:hover &#123; z-index: 6; background: hsla(1,100%,10%,1); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.two &#123; z-index: 2; top: 120px; left: 0; background: hsla(50, 70%, 50%, .5);&#125;.three &#123; z-index: 3; top: 120px; left: 160px; background: hsla(120, 70%, 50%, .5);&#125;.four &#123; z-index: 4; top: 120px; left: 320px; background: hsla(220, 70%, 50%, .5);&#125;.five &#123; z-index: 5; top: 120px; left: 480px; background: hsla(300, 70%, 50%, .5);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>summarize</tag>
      </tags>
  </entry>
</search>
