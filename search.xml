<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js-summarize]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文是基于JavaScript高级程序设计内容的一个总结，算作读书笔记？或者是备忘，也算是一种总结，希望能掌握一些基础的知识，更有利于以后的学习开发。与君共勉！Javascript诞生于1995年, 当时就职于Netscape 公司的布兰登·艾奇,计划于1995年2月发布由Netscape Navigator 2开发的脚本语音LiveScript,为了赶在发布日期之前，Netscape与Sun公司建立了一个开发联盟。在Netscape Navigator 发布前夕，Netscape为了搭载上热炒Java的顺风车，临时把LiveScript 改为 JavaScript。 Javascript 是一种专为与网页交互而设计的脚本语言，由以下三部分组成: ECMAScript，由ECMA-262定义，提供核心语言功能 文档对象模型（DOM）,提供访问和操作网页内容的方法和接口 浏览器对象模型（BOM）,提供与浏览器接口交互的方法和接口 在HTML中使用JavaScript &lt;script&gt;元素 &lt;script&gt;定义了6个属性 async: 可选 表示应该立即下载脚本，但不妨碍页面其他操作，只对外部脚本文件有效，不能保证异步脚本按照它们在页面的顺序执行 charset: 可选。 defer: 可选。表示脚本可以延迟到文档被完全解析后再执行。只对外部脚本文件有效，最好只包含一个延迟脚本，延迟脚本总是按照指定它们的顺序执行 language: 已废弃 src: 表示要引用的外部文件 type: 可选。表示编写代码使用的脚本语言的内容类型 &lt;noscript&gt;元素 在&lt;noscript中的内容在下面两种情况下才显示出来 浏览器不支持脚本 浏览器支持脚本，但被禁用 JavaScript将被从上到下依次执行,在所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载显示，在不使用defer和async的情况下 基本概念 1. 语法 1.1 区分大小写 ECMAScript中的一切(变量、函数名和操作符)都区分大小写 1.2 标识符 标识符 就是指变量、函数、属性或者函数参数。标识符规则如下 1 第一个字符必须是字母、下划线 或 $ 2 其他字符可以是字母、数字、下划线 或 $ 按照惯例，ECMAScript采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词首字母大写，如：firstSecond myCar 1.3 注释 // 单行注释 /* 这是一行多行注释 */ 1.4 严格模式 ECMAScript5引入严格模式，严格模式是为JavaScript定义了一种不同的解析与执行模型。要在整个模式启用严格模式，可以在顶部添加如下代码： “use strict” 1.5 语句 ECMAScript中的语句以一个分号结尾；虽然语句的分号不是必需的，但建议任何时候都不要省略它。 2. 数据类型 ECMAScript中有五种基本操作类型: Number、String、Bollean、Null、Undefined，还有一种复杂的数据类型Object。ECMAScript不支持任何创建自定义类型的机制，所有值最终将是上述6中类型之一。 2.1 typeof操作符 使用typeof检测数据类型，使用typeof操作符返回下列某个字符串： 1. “undefined”: 值未定义； 2. “Bollean”: 值是布尔值； 3. “string”: 值是字符串； 4. “number”: 值是数字； 5. “object”: 值是对象或者null； 2.2 Undefined类型 在使用var声明变量但未对其初始化时,这个变量的值就是Undefined,例如:12var message; //只定义了变量，未初始化变量alert(message === undefined) //true 注： 未声明的变量执行typeof也会返回undefined,初始化声明的变量是明智的选择。 2.3 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊值是null。从逻辑角度看，null表示一个空对象指针，而这也正是使用typeof操作符检测null值时返回”object”的原因。 实际上，undefined值是派生自null值得，因此ECMA-262规定对他们的相等性检测返回true1alert(null == undefined) // true 2.4 Bollean类型 该类型只有两个字面值：true和false 2.5 Number类型 这种类型使用IEEE754格式来表示整数和浮点数组。 最基本的数值字面量格式是十进制整数。如 var intNum = 55; //整数 除十进制表示外，整数还有八进制和十六进制，其中八进制第一位必须是零，然后八进制数字序列(0~7),如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值当作十进制数值解析。123 var octalNum1 = 070; //八进制的56 var octalNum2 = 079; //无效的八进制数值,解析为79 var octalNum3 = 08; //无效的八进制数值，解析为8 注： 八进制字面量在严格模式下是无效的。 十六进制字面量的前两位必须是0x,后跟任何十六进制数字(0~9及A~F)。其中可以大写，也可以小写。12var hexNum1 = 0xA; //十六进制的10var hexNum2 = 0x1f; //十六进制的31 2.5.1 数值范围 ECMAScript 能够保存的最小值保存在 Number.MIN_VALUE中，在大多数浏览器中这个数是5e-324。超过这个数值，则会被转换为-Infinity(负无穷)；最大值保存在Number.MAX_VALUE中，在大多数浏览器中这个数是1.7976931348623157e+308。超过这个数值，则会被转换为Infinity(正无穷) 2.5.2 NaN NaN，非数值(Not a Number) 是一个特殊的数值，这个数值表示一个本来要返回数值的操作数未返回数值的情况(这样就不抛出错误了)。例如: 任何数值除以0都会导致错误，但在ECMAScript中，任何数值除以0会返回NaN,不影响代码执行。 NaN两个特点: 1. 任何涉及NaN的操作(例如：NaN/10)都会返回NaN,在多步计算中可能导致问题。2. NaN与任何值都不相等，包括NaN本身。 ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型的数据，而函数会帮我们确定该参数是否”不是数值”12345isNaN(NaN) //trueisNaN(10) //false (10是一个数值)isNaN(&quot;10&quot;) //false (可以被转换成数值10)isNaN(&quot;blue&quot;) //true (不能转换成数值)isNaN(&quot;true&quot;) //false (可以被转换成数值1) 注: 实际上只有0除以0才会返回NaN，正数除以0返回Infinity,负数除以0返回-Infinity 2.5.3 数值转换 Number()、parseInt()、parseFloat()可以把非数值转换为数值。其中Number()可以用于任何数据类型，而另另个函数则专门用于把字符串转换成数值。这个函数对于同样的输入会有不同的返回结果。 Number()函数转换规则如下。 1. 如果是Boolean值，true和false将分别被转换为1和0 2. 数字值，只是简单的传入和返回。 3. null值，返回0。 4. undefined，返回NaN。 5. 如果是字符串，遵循下列规则: 1 如果字符串只包含数字，则将其转换为十进制数值 2 如果包含有效的浮点格式数据，则将其转换为对应的浮点数值。 3 如果包含有效的十六进制数据，则将其转换为相同大小的十进制整数值。 4 如果字符串为空，则将其转换为0。 5 如果字符串包含除上述以外的字符，则将其转换为NaN。 6. 如果是对象，则调用对象的valueOf()方法，然后按照前面规则转换返回的值。如果转换结果为NaN,则调用对象的toString()方法，然后再按照前面的规则转换返回的字符串值。1234Number(&apos;hello world&apos;) // NaNNumber(&quot; &quot;) // 0Number(&quot;00011&quot;) // 11Number(true) // 1 处理整数的时候更常用的是parseInt()函数。parseInt()函数规则如下： 1. 字符串第一个不是数字字符或者负号，parseInt()返回NaN,也就是说parseInt()转换空字符串也会返回NaN。 2. 如果第一个字符是字符串，则直到解析完后续的字符或者遇到了一个非数字字符。例如，”1234blue”会被转会为1234，类似的”22.5”会被转换为22，因为小数点并不是有效的数字字符。 3. 同样的parseInt()也能识别各种整数格式(即十进制、八进制、十六进制)，如果字符串以”0x”开头且后跟数字字符，就会将其当作十六进制整数；如果字符串以”0”开头且后跟数字字符，则会当作八进制数来解析。1234567parseInt(&quot;1234blue&quot;); //1234parseInt(&quot;&quot;); //NaNparseInt(&quot;0xA&quot;); //10parseInt(&quot;22.5&quot;); //22parseInt(&quot;070&quot;); //56parseInt(&quot;70&quot;); //70parseInt(&quot;0xf&quot;); //15 可以为函数提供第二个参数:转换时使用的基数(即多少进制)，例如：123parseInt(&quot;0xAF&quot;, 16); //175parseInt(&quot;AF&quot;, 16); //175parseInt(&quot;AF&quot;); //NaN 指定基数会影响到转换的输出结果。例如：1234parseInt(&quot;10&quot;, 2) //2 (按二进制解析)parseInt(&quot;10&quot;, 8) //8 (按八进制解析)parseInt(&quot;10&quot;, 10) //10 (按十进制解析)parseInt(&quot;10&quot;, 16) //16 (按十六进制解析) parseFloat()函数规则: 1. 与parseInt()函数类似，直到解析遇到无效的浮点数字字符为止。字符串中的第一个小数点是有效的，第二个小数点是无效的。例，”22.34.5”将会被转换为22.34 2. parseFloat()会忽略前导零。十六进制的字符串始终会被转换为0。parseFloat()只解析十进制数值。因此没有用第二个参数指定基数的用法。123456parseFloat(&quot;1234blue&quot;); //1234parseFloat(&quot;0xA&quot;); //0parseFloat(&quot;22.5&quot;); //22.5parseFloat(&quot;22.34.5&quot;); //22.34parseFloat(&quot;0908.5&quot;); //908.5parseFloat(&quot;3.125e7&quot;); //31250000 2.6 String类型 String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。 2.6.1 转换为字符串 方法一：toString()1234var age = 11;age.toString(); //字符串&quot;11&quot;var found = true;found.toString(); //字符串&quot;true&quot; 数值、布尔值、对象和字符串值都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是调用数值的toString()的方法时，可以传递一个参数：输出数值的基数。123456var num = 10;num.toString(); //&quot;10&quot;num.toString(&quot;2&quot;); //&quot;1010&quot;num.toString(&quot;10&quot;); //&quot;10&quot;num.toString(&quot;8&quot;); //&quot;12&quot;num.toString(&quot;16&quot;); //&quot;a&quot; 注： 默认(没有参数的)输出值与指定基数10时的输出值相同 方法二：string() 在不知道数值数是不是null或undefined的情况下，可以使用转型函数string();这个函数能够将任何类型的值转换为字符串。转换规则如下： 1 如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果。 2 如果值是null,则返回”null”。 3 如果值是undefined，则返回”undefined”123456789var value1 = 10;var value2 = true;var value3 = null;var value4;String(value1); //&quot;10&quot;String(value2); //&quot;true&quot;String(value3); //&quot;null&quot;String(value4); //&quot;undefined&quot; 2.7 Object类型 ECMAScript中的对象就是一组数据和功能的集合。对象可以执行new操作符后跟要创建的对象类型的名称来创建。如: var o = new Object(); Object类型是所有它的实例的基础。Object类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object每个实例都具有下列属性和方法： 1 constructor: 保存着用于创建当前对象的函数。对前面例子而言，构造函数(constructor)就是Object(); 2 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中(而不是在对象原型中存在)是否存在。作为参数的属性名(propertyName)必须以字符串的形式指定。(例如：o.hasOwnProperty(“name”)) 3 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型。 4 propertyIsEnumerable(propertyName): 用于检查给定的属性是否能用for-in语句来枚举。作为参数的函数名必须以字符串形式指定。 5 toLocalString(): 返回对象的字符串表示，该字符传与执行环境的地区对应。 6 toString(): 返回对象的字符串表示。 7 valueOf(): 返回对象的字符串、布尔值或数值表示。 3. 语句 3.1 if 语句 3.2 do-while 语句 在对条件表达式求值之前，循环体内的代码最少会被执行一次。1234var i = 0;do &#123; i += 2;&#125; while(i &lt; 10) 3.3 while 语句 while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。1234var i = 0;while ( i &lt; 10) &#123; i += 2;&#125; 3.4 for 语句 3.5 for-in 语句 for-in语句是一种精准的迭代语句，用来枚举对象的属性。for-in语句的语法： for(property in expression) statement123for (var propName in window) &#123; document.write(propName)&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>summarize</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-summarize]]></title>
    <url>%2F2018%2F12%2F13%2Fcss-summarize%2F</url>
    <content type="text"><![CDATA[写在前面：本文目的在于记录平时用到的一些常用CSS样式，常见的问题，用于以后自己方便使用，备忘。同时也希望对停留在这里的人，提供一些帮助！如何消除inline-block产生的元素间空隙 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 1.children &#123;display: inline-block;background: #ccc&#125; 运行结果： 空隙产生原因：HTML中的换行符、空格符、制表符等空白符，字体大小不为0的情况下，空白符占据一定宽度，使用inline-block会产生元素间的空隙 解决办法： 1. 父元素设置font-size设置为0，子元素的font-size设置为实际大小 2. 子元素设置浮动 3. 把所有子元素写在一行 4. 有时候子元素内容较长，所有子元素写在一行导致代码的可读性很差，这时候采用下面的写法（用HTML注释符把子元素连接起来）： 12345&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;!-- --&gt;&lt;div class=&quot;children&quot;&gt;child&lt;/div&gt;&lt;/div&gt; 图片和文字水平对齐实现 1234&lt;div class=&quot;wrapper&quot;&gt; &lt;p class=&quot;text&quot;&gt;文字&lt;/p&gt; &lt;img src=&quot;imgUrl&quot; alt=&quot;&quot; class=&quot;img&quot;&gt;&lt;/div&gt; 1234.text, .img &#123; display: inline-block; vertical-align: top;&#125; 多行文字垂直居中 1234// 元素高度不固定&lt;div class=&quot;parent&quot;&gt; &lt;p class=&quot;children&quot;&gt;桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖桃叶尖上尖&lt;/p&gt;&lt;/div&gt; 12345678// vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table.parent &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle;&#125; div实现水平垂直居中 123&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122// 1.container &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125;// 2.container &#123; display: flex; justify-content: center; align-items: center; height: 100%;&#125;.box &#123; width: 100px; height: 100px; background-color: red;&#125; flex实现左侧宽度固定，右侧宽度自适应 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left-part&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right-part&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567.left-part &#123; flex: 0 0 88px; width: 88px;&#125;.right-part &#123; flex: 1&#125; css-sticky-footer布局 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;warpper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;icon-footer&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.container &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(7, 17, 27, 0.8);&#125;.wrapper &#123; width: 100%; min-height: 100%;&#125;.content &#123; padding: 64px 0;&#125;.icon-footer &#123; margin: -64px auto 0;&#125; CSS3 transitions to the z-index 123456&lt;!-- Hover over the first div, labeled One, for at least three seconds to see how it transitions from a z-index value of 1 (the bottom of the stack) to a z-index value of 6 (top of the stack) --&gt; &lt;div class=&quot;one&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;three&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;four&lt;/div&gt; &lt;div class=&quot;five&quot;&gt;five&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546div &#123; position: absolute; height: 200px; width: 200px;&#125;.one &#123; z-index: 1; top: 0; left: 0; width: 800px; background: hsla(1, 70%, 50%, .5); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.one:hover &#123; z-index: 6; background: hsla(1,100%,10%,1); -moz-transition:all 3s; -webkit-transition:all 3s; transition:all 3s;&#125;.two &#123; z-index: 2; top: 120px; left: 0; background: hsla(50, 70%, 50%, .5);&#125;.three &#123; z-index: 3; top: 120px; left: 160px; background: hsla(120, 70%, 50%, .5);&#125;.four &#123; z-index: 4; top: 120px; left: 320px; background: hsla(220, 70%, 50%, .5);&#125;.five &#123; z-index: 5; top: 120px; left: 480px; background: hsla(300, 70%, 50%, .5);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>summarize</tag>
      </tags>
  </entry>
</search>
